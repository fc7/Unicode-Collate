#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Perl 5.6.1 ? */
#ifndef utf8n_to_uvuni
#define utf8n_to_uvuni  utf8_to_uv
#endif /* utf8n_to_uvuni */

/* if utf8n_to_uvuni() sets retlen to 0 (?) */
#define ErrRetlenIsZero "panic (Unicode::Collate): zero-length character"

static const UV max_div_16 = UV_MAX / 16;

/* Supported Levels */
#define MinLevel	(1)
#define MaxLevel	(4)

/* Shifted weight at 4th level */
#define Shift4Wt	(0xFFFF)
/*Variable weight at 1st level.
 This is a negative value but should be regarded as zero on collation.
 This is for distinction of variable chars from level 3 ignorable chars. */
#define Var1Wt		(-1)

#define Hangul_SBase	(0xAC00)
#define Hangul_SIni	(0xAC00)
#define Hangul_SFin	(0xD7A3)
#define Hangul_NCount	(588)
#define Hangul_TCount	(28)
#define Hangul_LBase	(0x1100)
#define Hangul_LIni	(0x1100)
#define Hangul_LFin	(0x1159)
#define Hangul_LFill	(0x115F)
#define Hangul_VBase	(0x1161)
#define Hangul_VIni	(0x1160)
#define Hangul_VFin	(0x11A2)
#define Hangul_TBase	(0x11A7)
#define Hangul_TIni	(0x11A8)
#define Hangul_TFin	(0x11F9)

#define CJK_UidIni	(0x4E00)
#define CJK_UidFin	(0x9FA5)
#define CJK_ExtAIni	(0x3400)
#define CJK_ExtAFin	(0x4DB5)
#define CJK_ExtBIni	(0x20000)
#define CJK_ExtBFin	(0x2A6D6)

MODULE = Unicode::Collate	PACKAGE = Unicode::Collate

PROTOTYPES: DISABLE

void
_getHexArray (src)
    SV* src
  PREINIT:
    U8 *s, *e;
    STRLEN byte;
    UV value;
    bool overflowed = FALSE;
    const char *hexdigit;
  PPCODE:
    s = (U8*)SvPV(src,byte);
    for (e = s + byte; s < e;) {
	hexdigit = strchr((char *) PL_hexdigit, *s++);
        if (! hexdigit)
	    continue;
	value = (hexdigit - PL_hexdigit) & 0xF;
	while (*s) {
	    hexdigit = strchr((char *) PL_hexdigit, *s++);
	    if (! hexdigit)
		break;
	    if (overflowed)
		continue;
	    if (value > max_div_16) {
		overflowed = TRUE;
		continue;
	    }
	    value = (value << 4) | ((hexdigit - PL_hexdigit) & 0xF);
	}
	XPUSHs(sv_2mortal(newSVuv(overflowed ? UV_MAX : value)));
    }


void
_isIllegal (sv)
    SV* sv
  PREINIT:
    UV uv;
  CODE:
    if (!sv || !SvIOK(sv))
	XSRETURN_YES;
    uv = SvUVX(sv);
    if (   0x10FFFF < uv		   /* out of range */
	|| ((uv & 0xFFFE) == 0xFFFE)       /* ??FFF[EF] (cf. utf8.c) */
	|| (0xD800 <= uv && uv <= 0xDFFF)  /* unpaired surrogates */
	|| (0xFDD0 <= uv && uv <= 0xFDEF)  /* other non-characters */
    )
	XSRETURN_YES;
    else
	XSRETURN_NO;


void
_decompHangul (code)
    UV code
  PREINIT:
    UV sindex, lindex, vindex, tindex;
  PPCODE:
    /* code *must* be in Hangul syllable.
     * Check it before you enter here. */
    sindex =  code - Hangul_SBase;
    lindex =  sindex / Hangul_NCount;
    vindex = (sindex % Hangul_NCount) / Hangul_TCount;
    tindex =  sindex % Hangul_TCount;

    XPUSHs(sv_2mortal(newSVuv(lindex + Hangul_LBase)));
    XPUSHs(sv_2mortal(newSVuv(vindex + Hangul_VBase)));
    if (tindex)
	XPUSHs(sv_2mortal(newSVuv(tindex + Hangul_TBase)));


void
getHST (code)
    UV code
  PREINIT:
    char * hangtype;
    STRLEN typelen;
  PPCODE:
    if (Hangul_LIni <= code && code <= Hangul_LFin || code == Hangul_LFill) {
	hangtype = "L"; typelen = 1;
    }
    else if (Hangul_VIni <= code && code <= Hangul_VFin) {
	hangtype = "V"; typelen = 1;
    }
    else if (Hangul_TIni <= code && code <= Hangul_TFin) {
	hangtype = "T"; typelen = 1;
    }
    else if (Hangul_SIni <= code && code <= Hangul_SFin) {
	if ((code - Hangul_SBase) % Hangul_TCount) {
	    hangtype = "LVT"; typelen = 3;
	} else {
	    hangtype = "LV"; typelen = 2;
	}
    }
    else {
	hangtype = ""; typelen = 0;
    }
    XPUSHs(sv_2mortal(newSVpvn(hangtype, typelen)));


void
_derivCE_9 (code)
    UV code
  PROTOTYPE: $
  PREINIT:
    UV base, aaaa, bbbb;
    U8 a[] = "\x00\xFF\xFF\x00\x20\x00\x02\xFF\xFF";
    U8 b[] = "\x00\xFF\xFF\x00\x00\x00\x00\xFF\xFF";
  PPCODE:
    base = (CJK_UidIni <= code && code <= CJK_UidFin)
	    ? 0xFB40 : /* CJK */
	   (CJK_ExtAIni <= code && code <= CJK_ExtAFin ||
	    CJK_ExtBIni <= code && code <= CJK_ExtBFin)
	    ? 0xFB80   /* CJK ext. */
	    : 0xFBC0;  /* others */
    aaaa =  base + (code >> 15);
    bbbb = (code & 0x7FFF) | 0x8000;
    a[1] = (U8)(aaaa >> 8);
    a[2] = (U8)(aaaa & 0xFF);
    b[1] = (U8)(bbbb >> 8);
    b[2] = (U8)(bbbb & 0xFF);
    a[7] = b[7] = (U8)(code >> 8);
    a[8] = b[8] = (U8)(code & 0xFF);
    XPUSHs(sv_2mortal(newSVpvn((char *) a, 9)));
    XPUSHs(sv_2mortal(newSVpvn((char *) b, 9)));


void
_derivCE_8 (code)
    UV code
  PROTOTYPE: $
  PREINIT:
    UV aaaa, bbbb;
    U8 a[] = "\x00\xFF\xFF\x00\x02\x00\x01\xFF\xFF";
    U8 b[] = "\x00\xFF\xFF\x00\x00\x00\x00\xFF\xFF";
  PPCODE:
    aaaa =  0xFF80 + (code >> 15);
    bbbb = (code & 0x7FFF) | 0x8000;
    a[1] = (U8)(aaaa >> 8);
    a[2] = (U8)(aaaa & 0xFF);
    b[1] = (U8)(bbbb >> 8);
    b[2] = (U8)(bbbb & 0xFF);
    a[7] = b[7] = (U8)(code >> 8);
    a[8] = b[8] = (U8)(code & 0xFF);
    XPUSHs(sv_2mortal(newSVpvn((char *) a, 9)));
    XPUSHs(sv_2mortal(newSVpvn((char *) b, 9)));


void
varCE (self, vce)
    SV* self
    SV* vce
  PREINIT:
    int i;
    IV wt[MaxLevel];
    SV ** svp;
    AV* av;
    HV *selfHV;
    U8 *a, *v;
    STRLEN alen, vlen;
  PPCODE:
    if (SvROK(self) && SvTYPE(SvRV(self)) == SVt_PVHV)
	selfHV = (HV*)SvRV(self);
    else
	croak("$self is not a HASHREF.");

    svp = hv_fetch(selfHV, "variable", 8, FALSE);
    if (!svp)
	croak("Panic: no $self->{variable} in varCE");

    a = SvPV(*svp, alen);
    v = SvPV(vce, vlen);
    av = newAV();
    av_extend(av, MaxLevel);

    for (i = 0; i < MaxLevel; i++) {
	wt[i] = (IV)(v[2 * i + 1] << 8 | v[2 * i + 2]);
    }

    /* variable: checked only the length and the first char,
       trusting checkCollator() and %VariableOK in Perl ... */
    if (alen == 7) {
	if (*a == 's') { /* shifted */
	    if (*v) {
		wt[3] = wt[0];
		wt[0] = Var1Wt;
		wt[1] = wt[2] = 0;
	    }
	    else
		wt[3] = wt[0] + wt[1] + wt[2] ? Shift4Wt : 0;
	}
	else if (*a == 'b') { /* blanked */
	    if (*v) {
		wt[0] = Var1Wt;
		wt[1] = wt[2] = 0;
	    }
	}

    }
    else if (alen == 13) {
	if (*a == 's') { /* shift-trimmed */
	    if (*v) {
		wt[3] = wt[0];
		wt[0] = Var1Wt;
		wt[1] = wt[2] = 0;
	    }
	    else
		wt[3] = 0;
	}
	/* no-op */ /* non-ignorable */
    }

    for (i = 0; i < MaxLevel; i++) {
	av_store(av, i, newSViv(wt[i]));
    }
    XPUSHs(sv_2mortal(newRV_noinc((SV*)av)));


void
mk_SortKey (self, buf)
    SV* self;
    SV* buf;
  PREINIT:
    SV  *dst, **svp, *eachlevel[MaxLevel];
    STRLEN dlen;
    U8  *d, *p, *e, *s[MaxLevel];
    AV  *bufAV, *wtAV;
    HV  *selfHV;
    UV back_flag;
    I32 i, buf_len;
    IV  lv, level, wt;
    bool upper_lower, kata_hira;
  PPCODE:
    if (SvROK(self) && SvTYPE(SvRV(self)) == SVt_PVHV)
	selfHV = (HV*)SvRV(self);
    else
	croak("$self is not a HASHREF.");

    svp = hv_fetch(selfHV, "level", 5, FALSE);
    level = svp ? SvIV(*svp) : MaxLevel;

    if (SvROK(buf) && SvTYPE(SvRV(buf)) == SVt_PVAV)
	bufAV = (AV*)SvRV(buf);
    else
	croak("not an ARRAYREF.");

    buf_len = av_len(bufAV);

    if (buf_len < 0) {
	PUSHs(sv_2mortal(newSVpvn("\x00\x00\x00\x00\x00\x00", 6)));
    }
    else {
	for (lv = 0; lv < level; lv++) {
	    eachlevel[lv] = sv_2mortal(newSV(2 * (1 + buf_len)));
	    (void)SvPOK_only(eachlevel[lv]);
	    s[lv] = SvPVX(eachlevel[lv]);
	}

	svp = hv_fetch(selfHV, "upper_before_lower", 18, FALSE);
	upper_lower = svp ? SvTRUE(*svp) : FALSE;
	svp = hv_fetch(selfHV, "katakana_before_hiragana", 24, FALSE);
	kata_hira = svp ? SvTRUE(*svp) : FALSE;

	for (i = 0; i <= buf_len; i++) {
	    svp = av_fetch(bufAV, i, FALSE);

	    if (svp && SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVAV)
		wtAV = (AV*)SvRV(*svp);
	    else
		croak("not an ARRAYREF: wtAV.");

	    for (lv = 0; lv < level; lv++) {
		svp = av_fetch(wtAV, lv, FALSE);
		wt = svp ? SvIV(*svp) : 0;

		if (lv == 2) {
		    if (upper_lower) {
			if (0x8 <= wt && wt <= 0xC) /* lower */
			    wt -= 6;
			else if (0x2 <= wt && wt <= 0x6) /* upper */
			    wt += 6;
			else if (wt == 0x1C) /* square upper */
			    wt++;
			else if (wt == 0x1D) /* square lower */
			    wt--;
		    }
		    if (kata_hira) {
			if (0x0F <= wt && wt <= 0x13) /* katakana */
			    wt -= 2;
			else if (0xD <= wt && wt <= 0xE) /* hiragana */
			    wt += 5;
		    }
		}

		if (0 < wt) {
		    *s[lv]++ = (U8)(wt >> 8);
		    *s[lv]++ = (U8)(wt & 0xFF);
		}
	    }
	}

	dlen = 2 * (MaxLevel - 1);
	for (lv = 0; lv < level; lv++)
	    dlen += s[lv] - (U8*)SvPVX(eachlevel[lv]);

	dst = sv_2mortal(newSV(dlen));
	(void)SvPOK_only(dst);
	d = SvPVX(dst);

	svp = hv_fetch(selfHV, "backwardsFlag", 13, FALSE);
	back_flag = svp ? SvUV(*svp) : (UV)0;

	for (lv = 0; lv < level; lv++) {
	    if (back_flag & (1 << (lv + 1))) {
		p = s[lv];
		e = (U8*)SvPVX(eachlevel[lv]);
		for ( ; e < p; p -= 2) {
		    *d++ = p[-2];
		    *d++ = p[-1];
		}
	    }
	    else {
		p = (U8*)SvPVX(eachlevel[lv]);
		e = s[lv];
		while(p < e)
		    *d++ = *p++;
	    }
	    if (lv + 1 < MaxLevel) { /* lv + 1 == real level */
		*d++ = '\0';
		*d++ = '\0';
	    }
	}

	for (lv = level; lv < MaxLevel; lv++) {
	    if (lv + 1 < MaxLevel) { /* lv + 1 == real level */
		*d++ = '\0';
		*d++ = '\0';
	    }
	}

	*d = '\0';
	SvCUR_set(dst, d - (U8*)SvPVX(dst));
	PUSHs(dst);
    }


void
visualizeSortKey (self, key)
    SV * self
    SV * key
  PREINIT:
    HV *selfHV;
    SV **svp, *dst;
    U8 *s, *e, *d;
    STRLEN klen, dlen;
    UV uv;
    IV ver;
    static char *upperhex = "0123456789ABCDEF";
  PPCODE:
    if (SvROK(self) && SvTYPE(SvRV(self)) == SVt_PVHV)
	selfHV = (HV*)SvRV(self);
    else
	croak("$self is not a HASHREF.");

    svp = hv_fetch(selfHV, "UCA_Version", 11, FALSE);
    if (!svp)
	croak("Panic: no $self->{UCA_Version} in visualizeSortKey");
    ver = SvIV(*svp);

    s = (U8*)SvPV(key, klen);

   /* slightly *longer* than the need, but I'm afraid of miscounting;
      exactly: (klen / 2) * 5 + MaxLevel * 2 - 1 (excluding '\0')
         = (klen / 2) * 5 - 1  # FFFF (16bit) and ' ' between 16bit units
         + (MaxLevel - 1) * 2  # ' ' and '|' for level boundaries
         + 2                   # '[' and ']'
   */
    dlen = (klen / 2) * 5 + MaxLevel * 2 + 2;
    dst = sv_2mortal(newSV(dlen));
    (void)SvPOK_only(dst);
    d = (U8*)SvPVX(dst);

    *d++ = '[';
    for (e = s + klen; s < e; s += 2) {
	uv = (U16)(*s << 8 | s[1]);
	if (uv) {
	    if ((d[-1] != '[') && ((9 <= ver) || (d[-1] != '|')))
		*d++ = ' ';
	    *d++ = upperhex[ (s[0] >> 4) & 0xF ];
	    *d++ = upperhex[  s[0]       & 0xF ];
	    *d++ = upperhex[ (s[1] >> 4) & 0xF ];
	    *d++ = upperhex[  s[1]       & 0xF ];
	}
	else {
	    if ((9 <= ver) && (d[-1] != '['))
		*d++ = ' ';
	    *d++ = '|';
	}
    }
    *d++ = ']';
    *d   = '\0';
    dlen = (STRLEN)(d - (U8*)SvPVX(dst));
    SvCUR_set(dst, dlen);
    XPUSHs(dst);



void
unpack_U (src)
    SV* src
  PREINIT:
    STRLEN srclen, retlen;
    U8 *s, *p, *e;
    UV uv;
  PPCODE:
    if (!SvUTF8(src)) {
	src = sv_mortalcopy(src);
	sv_utf8_upgrade(src);
    }
    s = (U8*)SvPV(src,srclen);
    e = s + srclen;

    for (p = s; p < e; p += retlen) {
	uv = utf8n_to_uvuni(p, e - p, &retlen, UTF8_ALLOW_ANY);
	if (!retlen)
	    croak(ErrRetlenIsZero);
	XPUSHs(sv_2mortal(newSVuv(uv)));
    }

