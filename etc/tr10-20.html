<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
       "http://www.w3.org/TR/html4/loose.dtd"> 

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<title>UTS #10: Unicode Collation Algorithm</title>
<link rel="stylesheet" type="text/css" href="../reports-web.css">
<style type="text/css">
<!--
span.marked  { font-weight: bold; border-style: dotted; border-width: 1px; background-color: 
               #00FF00 }
.unused      { background-color: #DDDDDD }
-->
</style>
</head>

<body bgcolor="#ffffff">

<table class="header">
	<tr>
		<td class="icon"><a href="http://www.unicode.org">
		<img align="middle" alt="[Unicode]" border="0" src="http://www.unicode.org/webscripts/logo60s2.gif" width="34" height="33"></a>&nbsp;
		<a class="bar" href="http://www.unicode.org/reports/">Technical Reports</a></td>
	</tr>
	<tr>
		<td class="gray">&nbsp;</td>
	</tr>
</table>
<div class="body">
	<h2 align="center">Unicode Technical Standard #10</h2>
	<h1>Unicode Collation Algorithm</h1>
	<table class="wide" cellspacing="2" cellpadding="2" border="1" width="90%">
		<tr>
			<td>Version</td>
			<td>5.2.0</td>
		</tr>
		<tr>
			<td>Authors</td>
			<td>Mark Davis (<a href="mailto:markdavis@google.com">markdavis@google.com</a>), 
			Ken Whistler (<a href="mailto:ken@unicode.org">ken@unicode.org</a>)</td>
		</tr>
		<tr>
			<td>Date</td>
			<td>2009-10-08</td>
		</tr>
		<tr>
			<td>This Version</td>
			<td>
			<a HREF="http://www.unicode.org/reports/tr10/tr10-20.html">
			http://www.unicode.org/reports/tr10/tr10-20.html</a></td>
		</tr>
		<tr>
			<td>Previous Version</td>
			<td>
			<a HREF="http://www.unicode.org/reports/tr10/tr10-18.html">
			http://www.unicode.org/reports/tr10/tr10-18.html</a></td>
		</tr>
		<tr>
			<td>Latest Version</td>
			<td><a href="http://www.unicode.org/reports/tr10/">http://www.unicode.org/reports/tr10/</a></td>
		</tr>
		<!-- Added proposed update line for 6.0 preparation. -->
		<tr>
			<td valign="top">Latest Proposed Update</td>
			<td valign="top"><a href="http://www.unicode.org/reports/tr10/proposed.html">http://www.unicode.org/reports/tr10/proposed.html</a></td>
		</tr>
		<tr>
			<td width="20%">Revision</td>
			<td><a href="#Modifications">20</a></td>
		</tr>
	</table>
	<p>&nbsp; </p>
	<h3><i>Summary</i></h3>
	<p><i>This report provides the specification of the Unicode Collation Algorithm, 
	which provides a specification for how to compare two Unicode strings while 
	remaining conformant to the requirements of The Unicode Standard. The UCA also 
	supplies the Default Unicode Collation Element Table (DUCET) as the data specifying 
	the default collation order for all Unicode characters.</i></p>
	<h3><i>Status</i></h3>
	<p><i>This document has been reviewed by Unicode members and other interested 
  parties, and has been approved for publication by the Unicode Consortium. 
  This is a stable document and may be used as reference material or cited as a 
  normative reference by other specifications.</i></p>
	<blockquote>
		<p><i><b>A Unicode Technical Standard (UTS)</b> is an independent specification. 
		Conformance to the Unicode Standard does not imply conformance to any UTS.</i></p>
	</blockquote>
	<p><i>Please submit corrigenda and other comments with the online reporting 
	form [<a href="#Feedback">Feedback</a>]. Related 
	information that is useful in understanding this document is found in the
	<a href="#References">References</a>. For the latest 
	version of the Unicode Standard see [<a href="#Unicode">Unicode</a>]. 
	For a list of current Unicode Technical Reports see [<a href="#Reports">Reports</a>]. 
	For more information about versions of the Unicode Standard, see [<a href="#Versions">Versions</a>].</i></p>
	<h3><i>Contents</i></h3>
	<ul class="toc">
		<li>1 <a href="#Introduction">Introduction</a>
		<ul class="toc">
			<li>1.1 <a href="#Multi_Level_Comparison">Multi-Level Comparison</a></li>
			<li>1.2 <a href="#Canonical_Equivalence">Canonical Equivalence</a></li>
			<li>1.3 <a href="#Contextual_Sensitivity">Contextual Sensitivity</a></li>
			<li>1.4 <a href="#Customization">Customization</a></li>
			<li>1.5 <a href="#Other_Applications_of_Collation">Other Applications 
			of Collation</a></li>
			<li>1.6 <a href="#Interleaved_Levels">Interleaved Levels</a></li>
			<li>1.7 <a href="#Performance">Performance</a></li>
			<li>1.8 <a href="#Common_Misperceptions">Common Misperceptions</a></li>
			<li>1.9 <a href="#Scope">The Unicode Collation Algorithm</a>
			<ul class="toc">
				<li>1.9.1 <a href="#Goals">Goals</a></li>
				<li>1.9.2 <a href="#Non-Goals">Non-Goals</a></li>
			</ul>
			</li>
		</ul>
		</li>
		<li>2 <a href="#Conformance">Conformance</a></li>
		<li>3 <a href="#Data_Table_Format">Collation Element Table</a>
		<ul class="toc">
			<li>3.1 <a href="#Linguistic_Features">Linguistic Features</a>
			<ul class="toc">
				<li>3.1.1 <a href="#Multiple_Mappings">Multiple Mappings</a>
				<ul class="toc">
					<li>3.1.1.1 <a href="#Expansions">Expansions</a></li>
					<li>3.1.1.2 <a href="#Contractions">Contractions</a></li>
					<li>3.1.1.3 <a href="#Other_Multiple_Mappings">Other Multiple 
					Mappings</a></li>
				</ul>
				</li>
				<li>3.1.2 <a href="#French_Accents">French Accents</a></li>
				<li>3.1.3 <a href="#Rearrangement">Rearrangement</a></li>
				<li>3.1.4 <a href="#Default_Values">Default Values</a></li>
				<li>3.1.5 <a href="#Collation_Graphemes">Collation Graphemes</a></li>
				<li>3.1.6 <a href="#Combining_Grapheme_Joiner">Combining Grapheme 
				Joiner</a></li>
			</ul>
			</li>
			<li>3.2 <a href="#Default_Unicode_Collation_Element_Table">Default Unicode 
			Collation Element Table</a>
			<ul class="toc">
				<li>3.2.1 <a href="#File_Format">File Format</a></li>
				<li>3.2.2 <a href="#Variable_Weighting">Variable Weighting</a></li>
			</ul>
			</li>
			<li>3.3 <a href="#Well-Formed">Well-Formed Collation Element Tables</a></li>
			<li>3.4 <a href="#Stability">Stability</a></li>
		</ul>
		</li>
		<li>4 <a href="#Main_Algorithm">Main Algorithm</a>
		<ul class="toc">
			<li>4.1 <a href="#Step_1">Normalize</a></li>
			<li>4.2 <a href="#Step_2">Produce Array</a></li>
			<li>4.3 <a href="#Step_3">Form Sort Key</a></li>
			<li>4.4 <a href="#Step_4">Compare</a></li>
		</ul>
		</li>
		<li>5 <a href="#Tailoring">Tailoring</a>
		<ul class="toc">
			<li>5.1 <a href="#Parametic_Tailoring">Parametric Tailoring</a></li>
			<li>5.2 <a href="#Preprocessing">Preprocessing</a></li>
		</ul>
		</li>
		<li>6 <a href="#Implementation_Notes">Implementation Notes</a>
		<ul class="toc">
			<li>6.1 <a href="#Reducing_Sort_Key_Lengths">Reducing Sort Key Lengths</a>
			<ul class="toc">
				<li>6.1.1 <a href="#Eliminating_level_separators">Eliminating Level 
				Separators</a></li>
				<li>6.1.2 <a href="#L2/L3_in_8_bits">L2/L3 in 8 Bits</a></li>
				<li>6.1.3 <a href="#Machine_Words">Machine Words</a></li>
				<li>6.1.4 <a href="#Run-length_Compression">Run-Length Compression</a></li>
			</ul>
			</li>
			<li>6.2 <a href="#Large_Weight_Values">Large Weight Values</a></li>
			<li>6.3 <a href="#Reducing_Table_Sizes">Reducing Table Sizes</a>
			<ul class="toc">
				<li>6.3.1 <a href="#Contiguous_weight_ranges">Contiguous Weight 
				Ranges</a></li>
				<li>6.3.2 <a href="#Escape_hatch">Escape Hatch</a></li>
				<li>6.3.3 <a href="#Leveraging_Unicode_tables">Leveraging Unicode 
				Tables</a></li>
				<li>6.3.4 <a href="#Reducing_the_Repertoire">Reducing the Repertoire</a></li>
				<li>6.3.5 <a href="#Memory_Table_Size">Memory Table Size</a></li>
			</ul>
			</li>
			<li>6.4 <a href="#Avoiding_Zero_Bytes">Avoiding Zero Bytes</a></li>
			<li>6.5 <a href="#Avoiding_Normalization">Avoiding Normalization</a></li>
			<li>6.6 <a href="#Case_Comparisons">Case Comparisons</a></li>
			<li>6.7 <a href="#Incremental_Comparison">Incremental Comparison</a></li>
			<li>6.8 <a href="#Catching_Mismatches">Catching Mismatches</a></li>
			<li>6.9 <a href="#Comparison_to_Java">Tailoring Example: Java</a></li>
			<li>6.10 <a href="#Flat_File_Example">Flat File Example</a>
			<ul class="toc">
				<li>6.10.1 <a href="#Collation_Element_Format">Collation Element 
				Format</a></li>
				<li>6.10.2 <a href="#Sample_Code">Sample Code</a></li>
			</ul>
			</li>
		</ul>
		</li>
		<li>7 <a href="#Weight_Derivation">Weight Derivation</a>
		<ul class="toc">
			<li>7.1 <a href="#Derived_Collation_Elements">Derived Collation Elements</a>
			<ul class="toc">
				<li>7.1.1 <a href="#Illegal_Code_Points">Illegal Code Points</a></li>
				<li>7.1.2 <a href="#Legal_Code_Points">Legal Code Points</a></li>
				<li>7.1.3 <a href="#Implicit_Weights">Implicit Weights</a></li>
				<li>7.1.4 <a href="#Trailing_Weights">Trailing Weights</a></li>
			</ul>
			</li>
			<li>7.2 <a href="#Canonical_Decompositions">Canonical Decompositions</a></li>
			<li>7.3 <a href="#Compatibility_Decompositions">Compatibility Decompositions</a>
			<ul class="toc">
				<li>7.3.1 <a href="#Tertiary_Weight_Table">Tertiary Weight Table</a></li>
			</ul>
			</li>
		</ul>
		</li>
		<li>8 <a href="#Searching">Searching and Matching</a><ul class="toc">
			<li>8.1 <a href="#Collation_Folding">Collation Folding</a></li>
		</ul>
		</li>
		<li>Appendix A: <a href="#Deterministic_Sorting">Deterministic_Sorting</a></li>
		<li><a href="#Acknowledgements">Acknowledgements</a></li>
		<li><a href="#References">References</a></li>
		<li><a href="#Modifications">Modifications</a></li>
	</ul>
	<br>
	<hr><br>
	<h2>1 <a name="Introduction">Introduction</a></h2>
	<p>Collation is the general term for the process and function of determining 
	the sorting order of strings of characters. It is a key function in computer 
	systems; whenever a list of strings is presented to users, they are likely to 
	want it in a sorted order so that they can easily and reliably find individual 
	strings. Thus it is widely used in user interfaces. It is also crucial for the 
	operation of databases, not only in sorting records but also in selecting sets 
	of records with fields within given bounds.</p>
	<p>However, collation is not uniform; it varies according to language and culture: 
	Germans, French and Swedes sort the same characters differently. It may also 
	vary by specific application: even within the same language, dictionaries may 
	sort differently than phonebooks or book indices. For non-alphabetic scripts 
	such as East Asian ideographs, collation can be either phonetic or based on 
	the appearance of the character. Collation can also be commonly customized or 
	configured according to user preference, such as ignoring punctuation or not, 
	putting uppercase before lowercase (or vice versa), and so on. Linguistically 
	correct <i>searching</i> also needs to use the same mechanisms: just as &quot;v&quot; 
	and &quot;w&quot; sort as if they were the same base letter in Swedish, a loose search 
	should pick up words with either one of them.</p>
	<p>Thus collation implementations must deal with the often-complex linguistic 
	conventions that communities of people have developed over the centuries for 
	ordering text in their language, and provide for common customizations based 
	on user preferences. And while doing all of this, of course, performance is 
	critical.</p>
	<p>The following table shows some examples of cases where sort order differs 
	by language, by usage, or by another customization.</p>
	<div align="center">
		<center>
		<table border="1" cellspacing="1" cellpadding="4">
			<caption><b>Example Differences</b></caption>
			<tr>
				<td width="33%" rowspan="2">Language</td>
				<td width="33%">Swedish:</td>
				<td width="33%">z &lt; ö</td>
			</tr>
			<tr>
				<td>German:</td>
				<td>ö &lt; z</td>
			</tr>
			<tr>
				<td rowspan="2">Usage</td>
				<td>German Dictionary:</td>
				<td>of &lt; öf</td>
			</tr>
			<tr>
				<td>German Telephone:</td>
				<td>öf &lt; of</td>
			</tr>
			<tr>
				<td rowspan="2">Customizations</td>
				<td>Upper-First</td>
				<td>A &lt; a</td>
			</tr>
			<tr>
				<td>Lower-First</td>
				<td>a &lt; A</td>
			</tr>
		</table>
		</center></div>
	<p>The conventions that people have developed over the centuries for collating 
	text in their language are often quite complex.&nbsp; Sorting all Unicode characters 
	in a uniform and consistent manner presents a number of challenges. And for 
	any collation mechanisms to be accepted in the marketplace, algorithms that 
	allow for good performance are crucial.</p>
	<p>Languages vary not only regarding which types of sorts to use (and in which 
	order they are to be applied), but also in what constitutes a fundamental element 
	for sorting. For example, Swedish treats <em>ä</em> as an individual letter, 
	sorting it after <em>z</em> in the alphabet; German, however, sorts it either 
	like <em>ae</em> or like other accented forms of <em>a</em>, thus following
	<em>a</em>. In Slovak, the digraph <i>ch</i> sorts as if it were a separate 
	letter after <i>h</i>. Examples from other languages (and scripts) abound. Languages 
	whose writing systems use uppercase and lowercase typically ignore the differences 
	in case, <i>unless</i> there are no other differences in the text.</p>
	<p>It is important to ensure that collation meets user expectations as fully 
	as possible. For example, in the majority of Latin languages, ø sorts as an 
	accented variant of o, meaning that most users would expect ø alongside o. However, 
	there are a few languages (Norwegian and Danish for example) that sort ø as 
	a unique sorting element after z. Sorting &quot;Søren&quot; after &quot;Sylt&quot; in a long list 
	— that is, as would be expected in Norwegian or Danish — will cause problems 
	if the user expects ø as a variant of o. A user will look for &quot;Søren&quot; between 
	&quot;Sorem&quot; and &quot;Soret&quot;, <i>not</i> see it in the selection, and assume the string 
	is missing - fooled by the fact that it has sorted in a completely different 
	location. In matching, the same can occur, which can cause significant problems 
	for software customers; and as with database selection, the user may not realize 
	what he is missing. See <i>Section 
	1.5, <a href="#Other_Applications_of_Collation">Other Applications of Collation</a></i>.<br>
	<br>
	With Unicode being deployed so widely, multilingual data becomes the rule, not 
	the exception. Furthermore, it is increasingly common to see users with many 
	different sorting expectations accessing the data. For example, a French company 
	with customers all over Europe will include names from many different languages 
	- French, German, Polish, Swedish, and so on. If a German employee at this French 
	company accesses the data, the customer names need to show up in the order that 
	meets this employee&#39;s expectations — that is, in a German order — even though 
	there will be many different accented characters that do not normally appear 
	in German text.</p>
	<p>For scripts and characters outside the use of a particular language, explicit 
	rules may not exist. For example, Swedish and French have clear and different 
	rules on sorting ä (either after z or as an accented character with a secondary 
	difference from a), but neither defines the ordering of other characters such 
	as Ж, ש, ♫, ∞, ◊, or ⌂.</p>
	<h3>1.1 <a name="Multi_Level_Comparison">Multi-Level Comparison</a></h3>
	<p>To address the complexities of language-sensitive sorting, a <i>multilevel</i> 
	comparison algorithm is employed. In comparing two words, for example, the most 
	important feature is the base character: such as the difference between an
	<i>A</i> and a <i>B</i>. Accent differences are typically ignored, if there 
	are any differences in the base letters. Case differences (uppercase versus 
	lowercase), are typically ignored, if there are any differences in the base 
	or accents. Punctuation is variable. In some situations a punctuation character 
	is treated like a base character. In other situations, it should be ignored 
	if there are any base, accent, or case differences. There may also be a final, 
	tie-breaking level, whereby if there are no other differences at all in the 
	string, the (normalized) code point order is used.</p>
	<div align="center">
		<center>
		<table border="1" cellspacing="1" cellpadding="4">
			<caption><i>Comparison Levels</i></caption>
			<tr>
				<th>Level</th>
				<th>Description*</th>
				<th>Examples</th>
			</tr>
			<tr>
				<th>L1</th>
				<td>Base characters</td>
				<td>role &lt; roles &lt; rule</td>
			</tr>
			<tr>
				<th>L2</th>
				<td>Accents</td>
				<td>role &lt; r<u>ô</u>le &lt; role<font color="#0000FF">s</font></td>
			</tr>
			<tr>
				<th>L3</th>
				<td>Case</td>
				<td>role &lt; <u>R</u>ole &lt; r<font color="#0000FF">ô</font>le</td>
			</tr>
			<tr>
				<th>L4</th>
				<td>Punctuation</td>
				<td>role &lt; <u>“</u>role<u>”</u> &lt; <font color="#0000FF">R</font>ole</td>
			</tr>
			<tr>
				<th>Ln</th>
				<td>Tie-Breaker</td>
				<td>role &lt; ro<u>□</u>le &lt; <font color="#0000FF">“</font>role<font color="#0000FF">”</font></td>
			</tr>
		</table>
		</center></div>
	<p>These examples are in English; the levels may correspond to different features 
	in other languages. Notice that in each example for levels L2 through Ln, the 
	differences on that level (indicated by the underlined characters) are swamped 
	by the stronger-level differences (indicated by the blue text). For example, 
	the L2 example shows that difference between an <u>o</u> and an accented <u>
	ô</u> is swamped by an L1 difference (the presence or absence of an <i>s</i>). 
	In the last example, the □ represents a format character, which is otherwise 
	completely ignorable.</p>
	<p>The core concept is that the primary level (L1) is for the basic sorting 
	of the text, and the non-primary levels (L2..Ln) are for tweaking other linguistic 
	elements in the writing system that are important to users in ordering, but 
	less important than the order of the basic sorting. In practice, not all of 
	these levels may be needed, depending on the user preferences or customizations.</p>
	<blockquote>
		<p><b>Note:</b> Many people see the Unicode code charts, and expect the 
		characters in their language to be in the &quot;correct&quot; order in the code charts. 
		Because collation varies by language — not just by script —, it is <i>not</i> 
		possible to arrange code points for characters so that simple binary string 
		comparison produces the desired collation order for all languages. Because 
		multi-level sorting is a requirement, it is not even possible to arrange 
		code points for characters so that simple binary string comparison produces 
		the desired collation order for any particular language. Separate data tables 
		are required for correct sorting order. For more information on tailorings 
		for different languages, see [<a href="#CLDR">CLDR</a>].</p>
		<p><b><i>The sorting weight of characters is not provided by their position 
		in the Unicode code charts.</i></b></p>
	</blockquote>
	<h3>1.2 <a name="Canonical_Equivalence">Canonical Equivalence</a></h3>
	<p>There are a number of cases in Unicode where two sequences of characters 
	are canonically equivalent; they are essentially the same character but can 
	be represented in different ways. For more information on what this means, see 
	[<a href="#UAX15">UAX15</a>].</p>
	<p>For collation, sequences that are canonically equivalent must sort the same. In 
	the table below are some examples. For example, the angstrom symbol was encoded 
	for compatibility, and is canonically equivalent to an A-ring. The latter is 
	also equivalent to the decomposed sequence of A plus the combining ring character. 
	The order of certain combining marks in many cases is also irrelevant, so these 
	must be sorted the same, as in the second example. In the third example, we 
	have a composed character that can be decomposed in four different ways, all 
	of which are canonically equivalent.</p>
	<div align="center">
		<center>
		<table border="1" cellspacing="1" cellpadding="4" class="example">
			<caption><b>Canonical Equivalence</b></caption>
			<tr>
				<td nowrap rowspan="3">1</td>
				<td nowrap>Å</td>
				<td>U+212B ANGSTROM SIGN</td>
			</tr>
			<tr>
				<td nowrap>Å</td>
				<td>U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE</td>
			</tr>
			<tr>
				<td nowrap>A ◌̊</td>
				<td>U+0041 LATIN CAPITAL LETTER A, U+030A COMBINING RING ABOVE</td>
			</tr>
			<tr>
				<td nowrap colspan="3">&nbsp;</td>
			</tr>
			<tr>
				<td nowrap rowspan="2">2</td>
				<td nowrap>x ◌̛ ◌̣</td>
				<td>U+0078 LATIN SMALL LETTER X, U+031B COMBINING HORN, U+0323 COMBINING 
				DOT BELOW</td>
			</tr>
			<tr>
				<td nowrap>x ◌̣ ◌̛</td>
				<td>U+0078 LATIN SMALL LETTER X, U+0323 COMBINING DOT BELOW, U+031B 
				COMBINING HORN</td>
			</tr>
			<tr>
				<td nowrap colspan="3">&nbsp;</td>
			</tr>
			<tr>
				<td nowrap rowspan="5">3</td>
				<td nowrap>ự</td>
				<td>U+1EF1 LATIN SMALL LETTER U WITH HORN AND DOT BELOW</td>
			</tr>
			<tr>
				<td nowrap>ụ◌̛</td>
				<td>U+1EE5 LATIN SMALL LETTER U WITH DOT BELOW, U+031B COMBINING 
				HORN</td>
			</tr>
			<tr>
				<td nowrap>u ◌̛ ◌̣</td>
				<td>U+0075 LATIN SMALL LETTER U, U+031B COMBINING HORN, U+0323 COMBINING 
				DOT BELOW</td>
			</tr>
			<tr>
				<td nowrap>ư ◌̣</td>
				<td>U+01B0 LATIN SMALL LETTER U WITH HORN, U+0323 COMBINING DOT 
				BELOW</td>
			</tr>
			<tr>
				<td nowrap>u ◌̣ ◌̛</td>
				<td>U+0075 LATIN SMALL LETTER U, U+0323 COMBINING DOT BELOW, U+031B 
				COMBINING HORN</td>
			</tr>
		</table>
		</center></div>
	<h3><br>
	1.3 <a name="Contextual_Sensitivity">Contextual Sensitivity</a></h3>
	<p>Beyond the concept of levels, there are additional complications in certain 
	languages, whereby the comparison is context sensitive: it depends on more than 
	just single characters compared directly against one another.</p>
	<p>First are contractions, where two (or more) characters sort as if they were 
	a single base character. In the table below, CH acts like a character after 
	C. Second are expansions, where a single character sorts as if it were two (or 
	more) characters in sorting. In the table below, an Œ ligature sorts as if it 
	were O + E. Both of these can be combined: that is, two (or more) characters 
	may sort as if they were a different sequence of two (or more) characters. In 
	the example below, for Japanese, a length mark sorts like the vowel of the previous 
	syllable: as an A after KA and as an I after KI.</p>
	<div align="center">
		<table border="1" cellspacing="1" cellpadding="4">
			<caption><b>Context Sensitivity</b></caption>
			<tr>
				<th>Contractions</th>
				<td>H &lt; Z<i>, but<br>
				</i>CH &gt; CZ</td>
			</tr>
			<tr>
				<th>Expansions</th>
				<td>OE &lt; Œ &lt; OF</td>
			</tr>
			<tr>
				<th>Both</th>
				<td>カー &lt; カイ<i>, but<br>
				</i>キー &gt; キイ</td>
			</tr>
		</table>
	</div>
	<p>There are some further oddities in the ways that languages work. Normally, 
	all differences in sorting are assessed going from the start to the end of the 
	string. If all of the base characters are the same, the first accent difference 
	determines the final order. In row 1 of the example below, the first accent 
	difference is on the <i>o</i>, so that is what determines the order. In French 
	and a few other languages, however, it is the <i>last</i> accent difference 
	that determines the order, as in row 2.</p>
	<div align="center">
		<table border="1" cellspacing="1" cellpadding="4">
			<caption><b>French Ordering</b></caption>
			<tr>
				<th>Normal Accent Ordering</th>
				<td>cote &lt; coté &lt; c<span class="marked"><span style="background-color: #00FF00">ô</span></span>te 
				&lt; c<span class="marked"><span style="background-color: #00FF00">ô</span></span>té</td>
			</tr>
			<tr>
				<th>French Accent Ordering</th>
				<td>cote &lt; côte &lt; cot<span class="marked"><span style="background-color: #00FF00">é</span></span> 
				&lt; côt<span class="marked"><span style="background-color: #00FF00">é</span></span></td>
			</tr>
		</table>
	</div>
	<p>&nbsp;</p>
	<h3>1.4 <a name="Customization">Customization</a></h3>
	<p>In practice, there are additional features of collation that users need control 
	over, which are expressed in user-interfaces and eventually in APIs. Other customizations 
	or user preferences include (but are not limited to) the following:</p>
	<ul>
		<li><i>Language. </i>As discussed above, this is the most important feature, 
		because it is crucial that the collation match the expectations of users 
		of the target language community.</li>
		<li><i>Strength. </i>Next to that is the <i>strength</i>, the number of 
		levels that are to be considered in comparison. For comparison, most of 
		the time a three-level strength will need to be used. In some cases, a larger 
		number of levels will be needed, while in others — especially in searching 
		— fewer levels will be desired.</li>
		<li><i>Case Ordering. </i>Some dictionaries and authors use uppercase before 
		lowercase while others use the reverse, so that needs to be customizable. 
		Sometimes the case ordering is mandated by the government, as in Denmark. 
		But often it is simply a customization or user preference. Another common 
		option is whether to treat punctuation (including spaces) as base characters 
		or treat them as a level 4 difference.</li>
		<li><i>User-Defined Rules.</i> Such rules provide specified results for 
		given combinations of letters. For example, in an index, an author may wish 
		to have symbols sorted as if they were spelled out, thus &quot;?&quot; may sort as 
		if it were &quot;question mark&quot;.</li>
		<li><i>Merging Tailorings.</i> These allow the merging of sets of rules 
		for different languages. For example, someone may want Latin characters 
		sorted as in French, <i>and</i> Arabic characters sorted as in Iranian. 
		In such an approach, generally one is the “master” in cases of conflicts.</li>
		<li><i>Script Order. </i>This allows users to determine which scripts come 
		first. For example, in an index an author may want the script of the text 
		of the book to come first. For example:
		<blockquote>
			<p>b &lt; ב &lt; β &lt; б <i>versus</i><br>
			β &lt; b &lt; б &lt; ב</p>
		</blockquote>
		<p>Attempting to achieve the same effect by introducing an extra strength 
		level before the first (primary) level would give incorrect results for 
		strings containing mixed scripts</p>
		</li>
		<li><i>Numbers: </i>This allows sorting numbers by numeric order. If numbers 
		are sorted alphabetically, “A-10” comes before “A-2”, which is often not 
		desired. This can be customized, but is much trickier than it sounds because 
		of ambiguities with recognizing numbers within strings (because they may 
		be formatted according to different language conventions). Once each number 
		is recognized, it can be preprocessed in place it into a format that allows 
		for correct numeric sorting, such as a textual version of the IEEE numeric 
		format.</li>
	</ul>
	<p>Note that phonetic sorting of Han characters requires use of either a lookup 
	dictionary of words or, more typically, special construction of programs or 
	databases to maintain an associated phonetic spelling for the words in the text.</p>
	<h3>1.5 <a name="Other_Applications_of_Collation">Other Applications of Collation</a></h3>
	<p>The same collation behavior has application in other realms than sorting. 
	In particular, searching should behave consistently with sorting. For example, 
	if <i>v</i> and <i>w</i> are treated as identical base letters in Swedish sorting, 
	then they should do so for searching. For searching, the ability to set the 
	maximal strength level is very important.</p>
	<p>Selection is the process of using the comparisons between the endpoints of 
	a range, as when using a SELECT command in a database query. It is crucial that 
	the correct range be returned, according to the users expectations. Consider 
	the example of a German businessman making a database selection, such as to 
	sum up revenue in each of of the cities from <i>O...</i> to <i>P...</i> for 
	planning purposes. If behind his back all cities starting with <i>Ö</i> are 
	excluded because the query selection is using a Swedish collation, there is 
	going to be one very unhappy customer.</p>
	<p>A sequence of characters considered to be a unit in collation, such as <i>
	ch</i> in Slovak, represents a <i>tailored</i> grapheme cluster. For applications 
	of this, see  <a href="http://www.unicode.org/reports/tr18/">UTS #18: Unicode 
	Regular Expressions</a> [<a href="#UTS18">UTS18</a>]. For more information 
	on grapheme clusters, see  <a href="http://www.unicode.org/reports/tr29/">UAX 
</a> [<a href="#UAX29">UAX29</a>].</p>
	<h3>1.6 <a name="Interleaved_Levels">Interleaved Levels</a></h3>
	<p>Levels may also need to be interleaved. Take, for example, sorting a database 
	according to two fields. The simplest way to sort is field by field, sequentially. 
	This gives us the results in column one in the example below. First all the 
	levels in Field 1 are compared, then all the levels in Field 2. The problem 
	with this approach is that high level differences in the second field are swamped 
	by minute differences in the first field. Thus we get unexpected ordering for 
	the first names.</p>
	<div align="center">
		<center>
		<table border="1" cellspacing="0" cellpadding="4">
			<caption><b>Merged Fields</b></caption>
			<tr>
				<th width="33%">Sequential</th>
				<th width="33%">Weak 1st</th>
				<th width="34%">Merged</th>
			</tr>
			<tr>
				<td width="33%">F1<sub>L1</sub>, F1<sub>L2</sub>, F1<sub>L3</sub>,<br>
				<font color="#0000FF">F2<sub>L1</sub>, F2<sub>L2</sub>, F2<sub>L3</sub></font></td>
				<td width="33%">F1<sub>L1</sub>,<br>
				<font color="#0000FF">F2<sub>L1</sub>, F2<sub>L2</sub>, F2<sub>L3</sub></font></td>
				<td width="34%">F1<sub>L1</sub>, <font color="#0000FF">F2<sub>L1</sub>,<br>
				</font>F1<sub>L2</sub>, <font color="#0000FF">F2<sub>L2</sub>,<br>
				</font>F1<sub>L3</sub>, <font color="#0000FF">F2<sub>L3</sub></font></td>
			</tr>
			<tr>
				<td width="33%">
				<table border="0" width="100%" class="noborder" cellpadding="2">
					<tr>
						<td width="50%"><font color="#FF0000">di Silva</font></td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%"><font color="#FF0000">di Silva</font></td>
						<td width="50%">Fred</td>
					</tr>
					<tr>
						<td width="50%">diSilva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">diSilva</td>
						<td width="50%">Fred</td>
					</tr>
					<tr>
						<td width="50%">disílva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">disílva</td>
						<td width="50%">Fred</td>
					</tr>
				</table>
				</td>
				<td width="33%">
				<table border="0" width="100%" class="noborder" cellspacing="0" cellpadding="2">
					<tr>
					  <td>disílva</td>
					  <td>Fred</td>
				  </tr>
					<tr>
					  <td>diSilva</td>
					  <td>Fred</td>
				  </tr>
					<tr>
					  <td><font color="#FF0000">di Silva</font></td>
					  <td>Fred</td>
				  </tr>
					<tr>
						<td width="50%"><font color="#FF0000">di Silva</font></td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">diSilva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">disílva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
				</table>
				</td>
				<td width="34%">
				<table border="0" width="100%" class="noborder" cellspacing="0" cellpadding="2">
					<tr>
					  <td><font color="#FF0000">di Silva</font></td>
					  <td>Fred</td>
				  </tr>
					<tr>
					  <td>diSilva</td>
					  <td>Fred</td>
				  </tr>
					<tr>
					  <td>disílva</td>
					  <td>Fred</td>
				  </tr>
					<tr>
						<td width="50%"><font color="#FF0000">di Silva</font></td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">diSilva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
					<tr>
						<td width="50%">disílva</td>
						<td width="50%"><font color="#FF0000">John</font></td>
					</tr>
				</table>
				</td>
			</tr>
		</table>
		</center></div>
	<p>A second way to do this is to ignore all but base-level differences in the 
	sorting of the first field. This gives us the results in column 2. The first 
	names are then all in the right order, but the problem is now that the first 
	field is not correctly ordered except on the base character level.</p>
	<p>The correct way to sort is to merge the fields in sorting, as shown in the 
	last column. Using this technique, all differences in the fields are taken into 
	account, and the levels are considered uniformly: accents in all fields are 
	ignored if there are any base character differences in any of the fields; case 
	in all fields is ignored if there are accent or base character differences in 
	any of the fields; and so on.</p>
	<h3>1.7 <a name="Performance">Performance</a></h3>
	<p>Collation is one of the most performance-critical features in a system. Consider 
	the number of comparison operations that are involved in sorting or searching 
	large databases, for example. Most production implementations will use a number 
	of optimizations to speed up string comparison.</p>
	<p>There is a common mechanism for preprocessing strings so that multiple comparisons 
	operations are much faster. With this mechanism, each collation engine provides 
	for the generation of a <i>sort key</i> from any given string. The binary comparison 
	of any two sort keys will yield the same result (less, equal, or greater) as 
	the collation engine would return for a comparison of the original strings. 
	Thus for a given collation C and any two strings A and B:</p>
	<p align="center">A ≤ B according to C if and only if sortkey(C, A) ≤ sortkey(C, 
	B)</p>
	<p>Still, simple string comparison is faster for any individual comparison. 
	This is easy to understand, because the generation of a sort key requires processing 
	an entire string, while in most string comparisons differences are found before 
	all the characters are processed. Typically there is a considerable difference 
	in performance, with simple string comparison being about 5 to 10 times faster 
	than generating sort keys and then using a binary comparison.</p>
	<p>However, sort keys can be much faster for multiple comparisons. Because binary 
	comparison is blindingly faster than string comparison, whenever there will 
	be more than about 10 comparisons per string — and the system can afford the 
	storage — it is faster to use sort keys.</p>
	<h3>1.8 <a name="Common_Misperceptions">Common Misperceptions</a></h3>
	<p>There are a number of common misperceptions about collation.</p>
	<ol>
		<li>Collation is <i>not</i> aligned with character sets or repertoires of 
		characters. Swedish and German share most of the same characters, for example, 
		but have very different sorting orders.</li>
		<li>Collation is <i>not</i> code point (binary) order. The simplest case 
		of this is capital Z versus lowercase a. As noted above, beginners may complain 
		about Unicode that a particular character is “not in the right place in 
		the code chart”. That is a misunderstanding of the role of the character 
		encoding in collation. While the Unicode Standard does not gratuitously 
		place characters such that the binary ordering is odd, the only way to get 
		the linguistically-correct order is to use a language-sensitive collation, 
		not a binary ordering.</li>
		<li>Collation is <i>not</i> a property of strings. Consider a list of cities, 
		with each city correctly tagged with its language. Despite this, a German 
		user will expect to see the cities all sorted according to German order, 
		and not expect to see a word with <i>ö</i> appear after <i>z</i>, simply 
		because the city has a Swedish name. As mentioned above it is of crucial 
		importance that if a German businessman makes a database selection, such 
		as to sum up revenue in each of of the cities from <i>O...</i> to <i>P...</i> 
		for planning purposes, then cities starting with <i>Ö</i> must<i> not</i> 
		be excluded.</li>
		<li>Collation order is <i>not</i> preserved under concatenation or substring 
		operations, in general. For example, the fact that x is less than y does 
		not mean that x + z is less than y + z. This is because characters may form 
		contractions across the substring or concatenation boundaries. In summary, 
		the following shows which implications <i>not</i> to expect.<p align="center">
		x &lt; y ↛ xz &lt; yz<br>
		x &lt; y ↛ zx &lt; zy<br>
		xz &lt; yz ↛ x &lt; y<br>
		zx &lt; zy ↛ x &lt; y<br>
&nbsp;</p>
		</li>
		<li>Collation order is <i>not</i> preserved when comparing sort keys generated 
		from different collation sequences. Remember that sort keys are a preprocessing 
		of strings according to a given set of collation features. From different 
		features, you will get different binary sequences. For example, suppose 
		we have two collations, F and G, where F is a French collation (with accents 
		compared from the end), and G is a German phonebook ordering. Then:<ul>
			<li>A ≤ B according to F if and only if sortkey(F, A) ≤ sortkey(F, B),
			<i>and</i></li>
			<li>A ≤ B according to G if and only if sortkey(G, A) ≤ sortkey(G, B)</li>
			<li>But the relation between sortkey(F, A) and sortkey(G, B) says <i>
			nothing</i> about whether A ≤ B according to F, <i>or</i> whether A 
			≤ B according to G.</li>
		</ul>
		</li>
		<li>Collation order is not a <i>stable sort;</i> that is a property of a 
		sort algorithm, not a collation sequence. For more information, see <i>
		Section 3.4, <a href="#Stability">Stability</a></i>.</li>
		<li>Collation order is <i>not</i> fixed. Over time, collation order will 
		vary: there may be fixes that are discovered as more information becomes 
		available about languages; there may be new government or industry standards 
		for the language that require changes; and finally, the new characters that 
		are added to Unicode periodically will interleave with the previously-defined 
		ones. Thus collations must be carefully versioned.</li>
	</ol>
	<h3>1.9 <a name="Scope">The Unicode Collation Algorithm</a><a name="Summary"></a></h3>
	<p>The Unicode Collation Algorithm (UCA) provides a specification for how to 
	compare two Unicode strings while remaining conformant to the requirements of
	<i>The Unicode Standard</i>. The UCA also supplies the Default Unicode Collation 
	Element Table (DUCET), which is data specifying the default collation order 
	for all Unicode characters. This table is designed so that it can be <i>tailored</i> 
	to meet the requirements of different languages and customizations.</p>
	<p>Briefly stated, the Unicode Collation Algorithm takes an input Unicode string 
	and a Collation Element Table, containing mapping data for characters. It produces 
	a sort key, which is an array of unsigned 16-bit integers. Two or more sort 
	keys so produced can then be binary-compared to give the correct comparison 
	between the strings for which they were generated.</p>
	<p>The Unicode Collation Algorithm assumes multiple-level key weighting, along 
	the lines widely implemented in IBM technology, and as described in the Canadian 
	sorting standard [<a href="#CanStd">CanStd</a>] and the International String 
	Ordering standard [<a href="#ISO14651">ISO14651</a>].</p>
	<p>By default, the algorithm makes use of three fully-customizable levels. For 
	the Latin script, these levels correspond roughly to:</p>
	<ol>
		<li>alphabetic ordering </li>
		<li>diacritic ordering </li>
		<li>case ordering. </li>
	</ol>
	<p>A final level for tie-breaking (semi-stability) may be used for tie-breaking 
	between strings not otherwise distinguished.</p>
	<p>This design allows implementations to produce culturally acceptable collation, 
	while putting the least burden on implementations in terms of memory requirements 
	and performance. In particular, Collation Element Tables only require storage 
	of 32 bits of collation data per significant character.</p>
	<p>However, implementations of the Unicode Collation Algorithm are not limited 
	to supporting only three levels. They are free to support a fully customizable 
	4th level (or more levels), as long as they can produce the same results as 
	the basic algorithm, given the right Collation Element Tables. For example, 
	an application which uses the algorithm, but which must treat some collection 
	of special characters as ignorable at the first three levels <i>and</i> must 
	have those specials collate in non-Unicode order (as, for example to emulate 
	an existing EBCDIC-based collation), may choose to have a fully customizable 
	4th level. The downside of this choice is that such an application will require 
	more storage, both for the Collation Element Table and in constructed sort keys.</p>
	<p>The Collation Element Table may be tailored to produce particular culturally 
	required orderings for different languages or locales. As in the algorithm itself, 
	the tailoring can provide full customization for three (or more) levels.</p>
	<h4>1.9.1 <a name="Goals">Goals</a></h4>
	<p>The algorithm is designed to satisfy the following goals:</p>
	<ol>
		<li>A complete, unambiguous, specified ordering for all characters in Unicode.
		</li>
		<li>A complete resolution of the handling of canonical and compatibility 
		equivalences as relates to the default ordering. </li>
		<li>A complete specification of the meaning and assignment of collation 
		levels, including whether a character is ignorable by default in collation.
		</li>
		<li>A complete specification of the rules for using the level weights to 
		determine the default collation order of strings of arbitrary length.
		</li>
		<li>Allowance for override mechanisms (<i>tailoring</i>) for creating language-specific 
		orderings. Tailoring can be provided by any well-defined syntax that takes 
		the default ordering and produces another well-formed ordering. </li>
		<li>An algorithm that can be efficiently implemented, both in terms of performance 
		and in terms of memory requirements. </li>
	</ol>
	<p>Given the standard ordering and the tailoring for any particular language, 
	any two companies or individuals — with their own proprietary implementations 
	— can take any arbitrary Unicode input and produce exactly the same ordering 
	of two strings. In addition, when given a tailoring specifying French accents 
	this algorithm passes the Canadian and ISO 14651 benchmarks ([<a href="#CanStd">CanStd</a>], 
	[<a href="#ISO14651">ISO14651</a>]).</p>
	<blockquote>
		<p><b>Note:</b> The Default Unicode Collation Element Table does not explicitly 
		list weights for all assigned Unicode characters. However, the algorithm 
		is well defined over <i>all</i> Unicode code points. See <i>
		Section 7.1.2, <a href="#Legal_Code_Points">Legal Code Points</a></i>.</p>
	</blockquote>
	<h4>1.9.2 <a name="Non-Goals">Non-Goals</a></h4>
	<p>The Default Unicode Collation Element Table (DUCET) explicitly does not provide for 
	the following features:</p>
	<ol>
		<li><i>Reversibility: </i>from a Collation Element you are not guaranteed 
		that you can recover the original character. </li>
		<li><i>Numeric formatting:</i> numbers composed of a string of digits or 
		other numerics will not necessarily sort in <i>numerical order.</i> </li>
		<li><i>API:</i> no particular API is specified or required for the algorithm.
		</li>
		<li><i>Title sorting:</i> for example, removing articles such as <i>a</i> 
		and <i>the </i>during bibliographic sorting is not provided. </li>
		<li><i>Stability of binary sort key values between versions:</i> For more 
		information, see <i>Section 3.4, <a href="#Stability">Stability</a></i>.</li>
		<li><i>Linguistic applicability:</i> to meet most user expectations, a linguistic 
		tailoring is needed. For more information, see <i>Section 
		5, <a href="#Tailoring">Tailoring</a></i>.</li>
	</ol>

	<p>The last feature, linguistic applicability, deserves further
	discussion. DUCET does not and cannot actually provide linguistically
	correct sorting for every language without further tailoring.
	That would be impossible, due to conflicting requirements for
	ordering different languages that share the same script. It
	isn't even possible in the specialized cases where a script
	may be predominantly used by a single language, because of the
	limitations of the DUCET table design and because of the
	requirement to keep implementation overhead minimized for
	all users of DUCET.</p>

	<p>The goal of DUCET is, instead, to provide a reasonable default
	ordering for all scripts that are <i>not</i> tailored. The
	expectation is that any characters used in the language of primary
	interest for collation will be tailored to meet all the appropriate
	linguistic requirements for that language. For example, for
	a user interested primarily in the Malayalam language, DUCET
	would be tailored to get all details correct for the expected Malayalam
	collation order, while leaving other characters
	(Greek, Cyrillic, Han, and so forth) in the default order, because the order
	of those other characters is not of primary concern. Conversely,
	a user interested primarily in the Greek language would use
	a Greek-specific tailoring, while leaving the Malayalam
	(and other) characters in their default order in the table.</p>


	<h2><a name="Conformance"></a>2 Conformance</h2>
	<p>There are many different ways to compare strings, and the Unicode Standard 
	does not restrict the ways in which implementations can do this. However, any 
	Unicode-conformant implementation that purports to implement the Unicode Collation 
	Algorithm must do so as described in this document.</p>
	<blockquote>
		<p><b>Note:</b> A conformance test for the UCA is available in [<a href="#Test">Test</a>].</p>
	</blockquote>
	<p>The algorithm is a <i>logical</i> specification, designed to be straightforward 
	to describe. Actual implementations of the algorithm are free to change any 
	part of the algorithm as long as any two strings compared by the implementation 
	are ordered the same as they would be by the algorithm. They are also free to 
	use a different format for the data in the Collation Element Table. The sort 
	key is also a <i>logical</i> intermediate object: as long as an implementation 
	produces the same results in comparison of strings, the sort keys can differ 
	in format from what is specified here. (See <i>
	Section 6, <a href="#Implementation_Notes">Implementation Notes</a></i>.)</p>
	<p>The requirements for conformance on implementations of the Unicode Collation 
	Algorithm are as follows:</p>
	<table class="noborder" cellpadding="8">
		<tr>
			<td class="noborder"><b><a name="C1">C1</a></b></td>
			<td class="noborder"><i>Given a well-formed Unicode Collation Element 
			Table, a conformant implementation shall replicate the same comparisons 
			of strings as those produced by Section 4,
			<a href="#Main_Algorithm">Main Algorithm</a>.</i>
			<p>In particular, a conformant implementation 
			must be able to compare any two canonically equivalent strings as being 
			equal, for all Unicode characters supported by that implementation.</p>
			<p>If a conformant implementation compares strings in a legacy character 
			set, it must provide the same results as if those strings had been transcoded 
			to Unicode.</p>
			</td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C2">C2</a></b></td>
			<td class="noborder"><i>A conformant implementation shall support at 
			least three levels of collation.</i>
			<p>A conformant implementation is 
			only required to implement three levels. However, it may implement four 
			(or more) levels if desired.</p>
			</td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C3">C3</a></b></td>
			<td class="noborder"><i>A conformant implementation that supports any 
			of the features backward levels, variable weighting, and semi-stability 
			shall do so in accordance with this specification.</i>
			<p>A conformant 
			implementation is not required to support these features; however, if 
			it does so, it must interpret them properly. Unless they are functioning 
			in a very restricted domain, it is strongly recommended that implementations 
			support a backwards secondary level, because this is required for French.</p>
			</td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C4">C4</a></b></td>
			<td class="noborder"><i>A conformant implementation must specify the 
			version number of this Unicode Technical Standard.</i>
			<p>The precise values of the collation elements for the characters may 
			change over time as new characters are added to the Unicode Standard. 
			The version number of this document is synchronized with the version 
			of the Unicode Standard for which it specifies the repertoire.</p>
			</td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C5">C5</a></b></td>
			<td class="noborder"><i>An implementation claiming conformance to Matching 
			and Searching according to UTS #10, shall meet the requirements described 
			in Section 8, <a href="#Searching">Searching and 
			Matching</a>.</i></td>
		</tr>
		<tr>
			<td width="1%" class="noborder"><b><a name="C6">C6</a></b></td>
			<td class="noborder"><i>An implementation claiming conformance to standard 
			UCA parametric tailoring shall do so in accordance with the specifications 
			Section 5, <a href="#Tailoring">Tailoring</a>.</i>
			<p>An implementation 
			claiming such conformance does not have to support all of the parameter 
			attributes and values; the only requirement is that those that it does 
			claim to support must behave as specified.</p>
			</td>
		</tr>
	</table>
	
	<h2><a name="Data_Table_Format">3 Collation Element Table</a></h2>
	
	<p>A Collation Element Table contains a mapping from one (or more) characters 
	to one (or more) <i>collation elements</i>, where a collation element is an 
	ordered list of three or more 16-bit weights. (All code points not explicitly 
	mentioned in the mapping are given an implicit weight: see <i>
	Section 7, <a href="#Weight_Derivation">Weight Derivation</a></i>).</p>
	<blockquote>
		<p><b>Note:</b> Implementations can produce the same result without using 
		16-bit weights — see <i>Section 6, <a href="#Implementation_Notes">Implementation 
		Notes</a></i>.</p>
	</blockquote>
	<p>The first weight is called the <i>Level 1</i> weight (or <i>primary</i> weight), 
	the second is called the <i>Level 2</i> weight (<i>secondary</i> weight), the 
	third is called the <i>Level 3</i> weight (<i>tertiary</i> weight), the fourth 
	is called the <i>Level 4</i> weight (<i>quaternary</i> weight), and so on. For 
	a collation element X, these can be abbreviated as X<sub>1</sub>, X<sub>2</sub>, 
	X<sub>3</sub>, X<sub>4</sub>, and so on. Given two collation elements X and 
	Y, we will use the following notation:</p>
	<div align="center">
		<table class="syntax" cellspacing="0" cellpadding="2">
			<caption><b>Equals Notation</b></caption>
			<tr>
				<th>Notation</th>
				<th>Reading</th>
				<th>Meaning</th>
			</tr>
			<tr>
				<td>X =<sub>1</sub> Y</td>
				<td><i>X is primary equal to Y</i></td>
				<td>X<sub>1</sub> = Y<sub>1</sub></td>
			</tr>
			<tr>
				<td>X =<sub>2</sub> Y</td>
				<td><i>X is secondary equal to Y</i></td>
				<td>X<sub>2</sub> = Y<sub>2</sub> and X =<sub>1</sub> 
				Y</td>
			</tr>
			<tr>
				<td>X =<sub>3</sub> Y</td>
				<td><i>X is tertiary equal to Y</i></td>
				<td>X<sub>3</sub> = Y<sub>3</sub> and X =<sub>2</sub> 
				Y</td>
			</tr>
			<tr>
				<td>X =<sub>4</sub> Y</td>
				<td><i>X is quaternary equal to Y</i></td>
				<td>X<sub>4</sub> = Y<sub>4</sub> and X =<sub>3</sub> 
				Y</td>
			</tr>
		</table>
	</div>
	<p>&nbsp;</p>
	<div align="center">
		<table class="syntax" cellspacing="0" cellpadding="2">
			<caption><b>Less Than Notation</b></caption>
			<tr>
				<th>Notation</th>
				<th>Reading</th>
				<th>Meaning</th>
			</tr>
			<tr>
				<td>X &lt;<sub>1</sub> Y</td>
				<td><i>X is primary less than Y</i></td>
				<td>X<sub>1</sub> &lt; Y<sub>1</sub></td>
			</tr>
			<tr>
				<td>X &lt;<sub>2</sub> Y</td>
				<td><i>X is secondary less than Y</i></td>
				<td>X &lt;<sub>1</sub> Y or (X =<sub>1</sub> Y and X<sub>2</sub> &lt; 
				Y<sub>2</sub>)</td>
			</tr>
			<tr>
				<td>X &lt;<sub>3</sub> Y</td>
				<td><i>X is tertiary less than Y</i></td>
				<td>X &lt;<sub>2</sub> Y or (X =<sub>2</sub> Y and X<sub>3</sub> &lt; 
				Y<sub>3</sub>)</td>
			</tr>
			<tr>
				<td>X &lt;<sub>4</sub> Y</td>
				<td><i>X is quaternary less than Y</i></td>
				<td>X &lt;<sub>3</sub> Y or (X =<sub>3</sub> Y and X<sub>4</sub> &lt; 
				Y<sub>4</sub>)</td>
			</tr>
		</table>
	</div>
	<p>Other operations are given their customary definitions in terms of the above. 
	That is: </p>
	<ul>
		<li>X <font size="3">≤</font><sub>n</sub> Y if and only if X &lt;<sub>n</sub> 
		Y or X =<sub>n</sub> Y</li>
		<li>X &gt;<sub>n</sub> Y if and only if Y &lt;<sub>n</sub> X</li>
		<li>X <font size="3">≥</font><sub>n</sub> Y if and only if Y
		<font size="3">≤</font><sub>n</sub> X</li>
	</ul>
	<table class="noBorder" align="right" width="33%" cellpadding="8">
		<tr>
			<td class="syntax">
			<p><b>Note:</b> Where only plain text ASCII characters are available 
			the following fallback notation can be used:</p>
			<div align="center">
				<table>
					<tr>
						<th>Notation</th>
						<th>Fallback</th>
					</tr>
					<tr>
						<td>X &lt;<sub>n</sub> Y</td>
						<td>X &lt;[n] Y</td>
					</tr>
					<tr>
						<td>X<sub>n</sub></td>
						<td>X[n]</td>
					</tr>
					<tr>
						<td>X <font size="3">≤</font><sub>n</sub> Y</td>
						<td>X &lt;=[n] Y</td>
					</tr>
					<tr>
						<td>A <font size="3">≡</font> B</td>
						<td>A <font size="3">=[a]</font> B</td>
					</tr>
				</table>
			</div>
			</td>
		</tr>
	</table>
	<p>The collation algorithm results in a similar ordering among characters and 
	strings, so that for two strings A and B we can write A &lt;<sub>2</sub> B, meaning 
	that A is less than B and there is a primary or secondary difference between 
	them. If A &lt;<sub>2</sub> B but A=<sub>1</sub> B, we say that there is <i>only</i> 
	a secondary difference between them. If two strings are equivalent (equal at 
	all levels) according to a given Collation Element Table, we write A
	<font size="3">≡</font> B. If they are bit-for-bit identical, we write A
	<font size="3">=</font> B.</p>
	<p>If a weight is 0000, then that collation element is <i>ignorable</i> at that 
	level: the weight at that level is not taken into account in sorting. A Level 
	N ignorable is a collation element that is ignorable at level N but not at level 
	N+1. Thus:</p>
	<ul>
		<li>A <i>Level 1 ignorable (or primary ignorable)</i> is a collation element 
		that is ignorable at Level 1, but not at Level 2;</li>
		<li>a <i>Level 2 ignorable (or secondary ignorable)</i> is ignorable at 
		Levels 1 and 2, but not Level 3;</li>
		<li>a <i>Level 3 ignorable (or tertiary ignorable) </i>is ignorable at Levels 
		1, 2, and 3 but not Level 4;</li>
	</ul>
	<p>In addition:</p>
	<ul>
		<li>A collation element that is not ignorable at any level is called a
		<i>non-ignorable</i>.</li>
		<li>A collation element with zeros at every level is called <i>completely 
		ignorable.</i></li>
	</ul>
	<p>For a given Collation Element Table, <i>MIN<sub>n</sub></i> is the least 
	weight in any collation element at level <i>n</i>, and <i>MAX<sub>n</sub></i> 
	is the maximum weight in any collation element at level <i>n</i>.</p>
	<p>The following are sample collation elements that are used in the examples 
	illustrating the algorithm. Unless otherwise noted, all weights are in hexadecimal 
	format.</p>
	<table class="wide">
		<caption>Sample Table</caption>
		<tr>
			<th align="LEFT" width="15%">
			<p align="LEFT">Character</p>
			</th>
			<th align="LEFT" width="30%">
			<p align="LEFT">Collation Element</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Name</p>
			</th>
		</tr>
		<tr>
			<td><code>0300 &quot;`&quot;</code></td>
			<td><code>[0000.0021.0002]</code></td>
			<td><code>COMBINING GRAVE ACCENT</code></td>
		</tr>
		<tr>
			<td><code>0061 &quot;a&quot;</code></td>
			<td><code>[06D9.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER A</code></td>
		</tr>
		<tr>
			<td><code>0062 &quot;b&quot;</code></td>
			<td><code>[06EE.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER B</code></td>
		</tr>
		<tr>
			<td><code>0063 &quot;c&quot;</code></td>
			<td><code>[0706.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER C</code></td>
		</tr>
		<tr>
			<td><code>0043 &quot;C&quot;</code></td>
			<td><code>[0706.0020.0008]</code></td>
			<td><code>LATIN CAPITAL LETTER C</code></td>
		</tr>
		<tr>
			<td><code>0064 &quot;d&quot;</code></td>
			<td><code>[0712.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER D</code></td>
		</tr>
	</table>
	<blockquote>
		<p><b>Note:</b> Weights in all examples are illustrative, and may not 
		match what is in the latest Default Unicode Collation Element Table.</p>
	</blockquote>
	<h3>3.1 <a name="Linguistic_Features">Linguistic Features</a></h3>
	<p>The following section describes the implications of the features discussed 
	in <i>Section 1, <a href="#Introduction">Introduction</a></i>.</p>
	
	<h4>3.1.1 <a name="Multiple_Mappings">Multiple Mappings</a></h4>
	
	<p>The mapping from characters to collation elements may not be a simple mapping 
	from one character to one collation element: in general, it may map from one 
	to many, from many to one, or from many to many. The following sections illustrate 
	this.</p>
	<h5>3.1.1.1 <a name="Expansions">Expansions</a></h5>
	<p>The Latin letter <i>æ</i> is treated as an independent letter by default. 
	Collations such as English, which may require treating it as equivalent to an
	<i>&lt;a e&gt;</i> sequence, can tailor the letter to map to a sequence of more than 
	one collation elements, such as in the following example:</p>
	<table class="wide">
		<tr>
			<th align="LEFT" width="15%">
			<p align="LEFT">Character</p>
			</th>
			<th align="LEFT" width="30%">
			<p align="LEFT">Collation Element</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Name</p>
			</th>
		</tr>
		<tr>
			<td><code>00E6</code></td>
			<td><code>[06D9.0020.0002], [073A.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER AE; &quot;æ&quot;</code></td>
		</tr>
	</table>
	<p>In this example, the collation element <tt>[06D9.0020.0002]</tt> gives the 
	weight values for <i>a</i>, and the collation element <tt>[073A.0020.0002]</tt> 
	gives the weight values for <i>e</i>.</p>
	<h5>3.1.1.2 <a name="Contractions">Contractions</a></h5>
	<p>Similarly, where <i>ch</i> is treated as a single letter as in traditional 
	Spanish, it is represented as a mapping from two characters to a single collation 
	element, such as in the following example:</p>
	<table class="wide">
		<tr>
			<th align="LEFT" width="15%">
			<p align="LEFT">Character</p>
			</th>
			<th align="LEFT" width="30%">
			<p align="LEFT">Collation Element</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Name</p>
			</th>
		</tr>
		<tr>
			<td><code>0063<br>
			0068</code></td>
			<td><code>[0707.0020.0002]</code></td>
			<td><code>LATIN SMALL LETTER C,<br>
			LATIN SMALL LETTER H; &quot;ch&quot;</code></td>
		</tr>
	</table>
	<p>In this example, the collation element <tt>[0707.0020.0002]</tt> has a primary 
	value one greater than the primary value for the letter <i>c</i> by itself, 
	so that the sequence <i>ch</i> will collate after <i>c</i> and before <i>d</i>. 
	The above example shows the result of a tailoring of collation elements to weight 
	sequences of letters as a single unit.</p>
	<p>Any character (such as <i>soft hyphen</i>) that is not completely ignorable 
	between two characters of a contraction will cause them to sort as separate 
	characters. Thus a soft hyphen can be used to separate and cause distinct weighting 
	of sequences such as Slovak <i>ch</i> or Danish <i>aa</i> that would normally 
	weight as units.</p>
	<p>Contractions that end with <i>non-starter</i> characters are known as <i>
	discontiguous contractions.</i> For example, suppose that there is a contraction 
	of <i>&lt;<b>a, combining ring above</b>&gt;</i>, as in Danish where this sorts as 
	after &quot;z&quot;. If the input text contains the sequence <i>&lt;<b>a</b>, combining dot 
	below, <b>combining ring above</b>&gt;</i>, then the contraction still needs to 
	be detected. This is required because the rearrangement of the combining marks 
	is canonically equivalent:</p>
	<p align="center"><i>&lt;<b>a</b>, combining dot below, <b>combining ring above</b>&gt;<br>
	≡<br>
	&lt;<b>a</b>, <b>combining ring above</b>, combining dot below&gt;.</i></p>
	<p>That is, discontiguous contractions must be detected in input text whenever 
	the final sequence of non-starter characters could be rearranged so as to make 
	a contiguous matching sequence that is canonically equivalent. In the formal 
	algorithm this is handled by rule Rule <a href="#S2.1">S2.1</a>. For information 
	on non-starters, see [<a href="#UAX15">UAX15</a>].</p>
	
	<h5>3.1.1.3 <a name="Other_Multiple_Mappings">Other Multiple Mappings</a></h5>
	
	<p>Certain characters may both expand and contract: see <i>
	Section 1.3, <a href="#Contextual_Sensitivity">Contextual Sensitivity</a>.</i></p>
	
	<h4>3.1.2 <a name="French_Accents">French Accents</a></h4>
	
	<p>In some languages (notably French), accents are sorted from the back of the 
	string to the front of the string. This behavior is not marked in the Default 
	Unicode Collation Element Table, but may occur in tailored tables. In such a 
	case, the collation elements for the accents and their base characters are marked 
	as being <i>backwards</i> at Level 2.</p>
	
	<h4>3.1.3 <a name="Rearrangement">Rearrangement</a></h4>
	
	<p>Certain characters are not coded in logical order, such as the Thai vowels 
	เ through ไ and the Lao vowels ເ through ໄ (this list is indicated by the Logical_Order_Exception 
	property in the Unicode Character Database [<a href="#UAX44">UAX44</a>]). For collation, 
	they are rearranged by swapping with the following character before further 
	processing, because logically they belong afterwards. This is done by providing 
	these sequences as contractions in the Collation Element Table.<br>
	</p>
	<h4>3.1.4 <a name="Default_Values">Default Values</a></h4>
	<p>Both in the Default Unicode Collation Element Table and in typical tailorings, 
	most unaccented letters differ in the primary weights, but have secondary weights 
	(such as <i>a<sub>1</sub></i>) equal to <i>MIN<sub>2</sub></i>. The primary 
	ignorables will have secondary weights greater than <i>MIN<sub>2</sub></i>. 
	Characters that are compatibility or case variants will have equal primary and 
	secondary weights (for example, <i>a<sub>1</sub> = A<sub>1</sub></i> and <i>
	a<sub>2</sub> = A<sub>2</sub></i>), but have different tertiary weights (for 
	example, <i>a<sub>3</sub> &lt; A<sub>3</sub></i>). The unmarked characters will 
	have tertiary weights (such as <i>a<sub>3</sub></i>) equal to <i>MIN<sub>3</sub>.</i></p>
	<p>However, a well-formed Unicode Collation Element Table <i>does not</i> guarantee 
	that the meaning of a secondary or tertiary weight is uniform across tables. 
	For example, a <i>capital A</i> and <i>katakana ta</i> could both have a tertiary 
	weight of 3.</p>
	<h4>3.1.5 <a name="Collation_Graphemes">Collation Graphemes</a></h4>
	<p>A collation ordering determines a <i>collation grapheme cluster</i> (also 
	known as a collation grapheme or collation character), which is a sequence of 
	characters that is treated as a primary unit by the ordering. For example,
	<i>ch</i> is a collation grapheme for a traditional Spanish ordering. These 
	are generally contractions, but may include additional ignorable characters. 
	To determine the boundaries for a collation grapheme starting at a given position, 
	use the following process:</p>
	<ol>
		<li>Set <code>oldPosition</code> to be equal to <code>position</code>.</li>
		<li>If <code>position</code> is at the end of the string, return it.</li>
		<li>Fetch the next collation element(s) mapped to by the character(s) at
		<code>position</code>.</li>
		<li>If the collation element(s) contain a non-ignorable and <code>position</code> 
		is not equal to <code>oldPosition</code>, return <code>position</code>.</li>
		<li>Otherwise set <code>position</code> to be the end of the characters 
		mapped.</li>
		<li>Loop back to step 2.</li>
	</ol>
	<p>For information on the use of collation graphemes, see [<a href="#UTS18">UTS18</a>].</p>
	<h4>3.1.6 <a name="Combining_Grapheme_Joiner">Combining Grapheme Joiner</a></h4>
	<p>The Unicode Collation Algorithm involves the normalization of Unicode text 
	strings before collation weighting. The U+034F COMBINING GRAPHEME JOINER (CGJ) 
	is ordinarily ignored in collation key weighting in the UCA, but it can be used 
	to block the reordering of combining marks in a string as described in [<a href="#Unicode">Unicode</a>]. 
	In that case, its effect can be to invert the order of secondary key weights 
	associated with those combining marks. Because of this, the two strings would 
	have distinct keys, making it possible to treat them distinctly in searching 
	and sorting without having to further tailor either the combining grapheme joiner 
	or the combining marks themselves.</p>
	<p>The CGJ can also be used to prevent the formation of contractions in the 
	Unicode Collation Algorithm. Thus, for example, while <i>ch</i> is sorted as 
	a single unit in a tailored Slovak collation, the sequence &lt;<i>c</i>, CGJ,
	<i>h</i>&gt; will sort as a <i>c</i> followed by an <i>h</i>. This can also be 
	used in German, for example, to force <i>ü</i> to be sorted as <i>u + umlaut</i> 
	(thus <i>u</i> &lt;<sub>2</sub> <i>ü</i>), even where a dictionary sort is being 
	used (which would sort <i>ue</i> &lt;<sub>3</sub> <i>ü)</i>. This happens without 
	having to further tailor either the combining grapheme joiner or the sequence.</p>
	<blockquote>
		<p><b>Note: </b>As in a few other cases in Unicode, such as U+200B ZERO 
		WIDTH SPACE (which is not a white space character), the name of the CGJ 
		is misleading: the usage above is in some sense the inverse of &quot;joining&quot;.</p>
	</blockquote>
	<p>Sequences of characters which include the combining grapheme joiner or other 
	completely ignorable characters may also be given tailored weights. Thus the 
	sequence &lt;<i>c</i>, CGJ, <i>h</i>&gt; could be weighted completely differently 
	from the either the contraction <i>ch</i> or how <i>c</i> and <i>h</i> would 
	have sorted without the contraction. However, this application of CGJ is not 
	recommended, because it would produce effects much different than the normal 
	usage above, which is to simply interrupt contractions.</p>
	<h3>3.2 <a name="Default_Unicode_Collation_Element_Table">Default Unicode Collation 
	Element Table</a></h3>
	<p>The Default Unicode Collation Element Table is provided in [<a href="#AllKeys">AllKeys</a>]. 
	This table provides a mapping from characters to collation elements for all 
	the explicitly weighted characters. The mapping lists characters in the order 
	that they would be weighted. Any code points that are not explicitly mentioned 
	in this table are given a derived collation element, as described in <i>
	Section 7, <a href="#Weight_Derivation">Weight Derivation</a></i>. There are 
	three types of mappings:</p>
	<ul>
		<li><b>Normal. </b>One Unicode character maps to one collation element.</li>
		<li><b>Expansions.</b> One Unicode character maps to a sequence of collation 
		elements.</li>
		<li><b>Contractions.</b> A sequence of Unicode characters maps to a sequence 
		of (one or more) collation elements.</li>
	</ul>
	<p>The Default Unicode Collation Element Table does not aim to provide precisely 
	correct ordering for each language and script; tailoring is required for correct 
	language handling in almost all cases. The goal is instead to have all the
	<i>other</i> characters, those that are not tailored, show up in a reasonable 
	order. In particular, this is true for contractions, because the use of contractions 
	can result in larger tables and significant performance degradation. While contractions 
	are required in tailorings, in the Default Unicode Collation Element Table their 
	use is kept to the bare minimum to avoid such problems. </p>
	<p>In the Default Unicode Collation Element Table, contractions are required 
	in those instances where a canonically decomposable character requires a distinct 
	primary weight in the table, so that the canonically equivalent character sequences 
	are also given the same weights. For example, Indic two-part vowels have primary 
	weights as units, and their canonically equivalent sequence of vowel parts must 
	be given the same primary weight by means of a contraction entry in the table. 
	The same applies to a number of precomposed Cyrillic characters with diacritic 
	marks and to a small number of Arabic letters with <i>madda</i> or <i>hamza</i> 
	marks. </p>
	<p>Contractions are also entered in the table for Thai and Lao logical order 
	exception vowels. Because both Thai and Lao both have five vowels that are represented 
	in strings in visual order, instead of logical order, they cannot simply be 
	weighted by their representation order in strings. One option is to require 
	preprocessing of Thai and Lao strings, to identify and reorder all logical order 
	exception vowels around the following consonant. That approach was used in Version 
	4.0 (and earlier) of the UCA. Starting with Version 4.1 of the UCA, contractions 
	for the relevant combinations of Thai and Lao vowel+consonant have been entered 
	in the Default Unicode Collation Element Table instead.</p>
	<p>Those are the only two classes of contractions allowed in the Default Unicode 
	Collation Element Table. Generic contractions of the sort needed, for example, 
	to handle digraphs such as &quot;ch&quot; in Spanish or Czech sorting, should be dealt 
	with instead in tailorings to the default table -- in part because they often 
	vary in ordering from language to language, and in part because every contraction 
	entered into the default table has a significant implementation cost for all 
	applications of the default table, even those which may not be particularly 
	concerned with the affected script. See the Unicode
	<a href="http://unicode.org/cldr/">Common Locale Data Repository</a> (CLDR) 
	for extensive tailorings of the DUCET for various languages, including those 
	requiring contractions. </p>
	<p>This table is constructed to be consistent with the Unicode Canonical Equivalence 
	algorithm, and to respect the Unicode character properties. It is not, however, 
	merely algorithmically derivable from those data, because the assignment of 
	levels does take into account characteristics of particular scripts. For example, 
	in general the combining marks are Level 1 ignorables; however, the Indic combining 
	vowels are given non-zero Level 1 weights, because they are as significant in 
	sorting as the consonants.</p>
	<p>Any character may have variant forms or applied accents which affect collation. 
	Thus, for <tt>FULL STOP</tt> there are three compatibility variants, a fullwidth 
	form, a compatibility form, and a small form. These get different tertiary weights, 
	accordingly. For more information on how the table was constructed, see <i>
	Section 7, <a href="#Weight_Derivation">Weight Derivation</a></i>.</p>
	<p>The following table shows the layout of the collation elements in the Default 
	Unicode Collation Element Table, ordered by primary weight:</p>
	<center>
	<table class="example">
		<caption>DUCET Layout</caption>
		<tr>
			<th align="center">Values</th>
			<th align="center">Range</th>
			<th align="center">Types of Characters</th>
		</tr>
		<tr>
			<td>X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub> = 0</td>
			<td>tertiary ignorables</td>
			<td>- Control Codes<br>
			- Format Characters<br>
			- Hebrew Points<br>
			- Tibetan Signs<br>
			...</td>
		</tr>
		<tr>
			<td>X<sub>1</sub>, X<sub>2</sub> = 0;<br>
			X<sub>3</sub> ≠ 0</td>
			<td>secondary ignorables</td>
			<td><i>None in DUCET; could be in tailorings</i></td>
		</tr>
		<tr>
			<td>X<sub>1</sub> = 0;<br>
			X<sub>2</sub>, X<sub>3</sub> ≠ 0</td>
			<td>primary ignorable</td>
			<td>- Most nonspacing marks</td>
		</tr>
		<tr>
			<td rowspan="4">X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub> ≠ 0</td>
			<td><a href="#Variable_Weighting">variable</a></td>
			<td>- Whitespace<br>
			- Punctuation<br>
			- Symbols</td>
		</tr>
		<tr>
			<td>regular</td>
			<td>- Small number of exceptional symbols (for example, U+02D0 (ː)
			<i>triangular colon</i>)<br>
			- Numbers<br>
			- Latin<br>
			- Greek<br>
			...</td>
		</tr>
		<tr>
			<td><a href="#Implicit_Weights">implicit</a></td>
			<td>- CJK &amp; CJK compatibility (those not decomposed)<br>
			- CJK Extension A &amp; B<br>
			- Unassigned and others given implicit weights</td>
		</tr>
		<tr>
			<td><a href="#Trailing_Weights">trailing</a></td>
			<td><i>None in DUCET; could be in tailorings</i></td>
		</tr>
	</table>
	</center>
	<p>For most languages, some degree of tailoring is required to match user expectations. 
	For more information, see <i>Section 5, <a href="#Tailoring">Tailoring</a></i>.</p>
	
	<h4>3.2.1 <a name="File_Format">File Format</a></h4>
	
	<p>Each of the files consists of a version line followed by an optional variable-weight 
	line, optional backwards lines, and a series of entries, all separated by newlines. 
	A &#39;#&#39; or &#39;%&#39; and any following characters on a line are comments. Whitespace 
	between literals is ignored. The following is an extended BNF description of 
	the format, where &quot;<i>x</i>+&quot; indicates one or more <i>x</i>&#39;s, &quot;<i>x</i>*&quot; 
	indicates zero or more <i>x</i>&#39;s, &quot;<i>x?</i>&quot; indicates zero or one <i>x</i>, 
	and &lt;char&gt; is a hexadecimal Unicode code value.</p>
	<pre>&lt;collationElementTable&gt; := &lt;version&gt; 
                           &lt;variable&gt;?
                           &lt;backwards&gt;*
                           &lt;entry&gt;+</pre>
	<p>The version line is of the form:</p>
	<pre>@&lt;version&gt; := &lt;major&gt;.&lt;minor&gt;.&lt;variant&gt; &lt;eol&gt;</pre>
	<p>The variable-weight line has three possible values that may change the weights 
	of collation elements in processing (see <i>
	Section 3.2.2, <a href="#3.2.2_Variable_Collation_Elements">Variable Weighting</a></i>). 
  The default is <code>shifted</code>.</p>
	<pre>&lt;variable&gt;       := &#39;@variable &#39; &lt;variableChoice&gt; &lt;eol&gt;
&lt;variableChoice&gt; := &#39;blanked&#39; | &#39;non-ignorable&#39; | &#39;shifted&#39;<span style="background-color:#FFFF00"></span></pre>
	<p>A backwards line lists a level that is to be processed in reverse order. 
  A forwards line does the reverse. The default is for lines to be forwards.</p>
	<pre>&lt;backwards&gt; := (&#39;@backwards &#39; | &#39;@forwards &#39;) &lt;levelNumber&gt; &lt;eol&gt;</pre>
	<p>Each entry is a mapping from character(s) to collation element(s), and is 
	of the following form:</p>
	<pre>&lt;entry&gt;       := &lt;charList&gt; &#39;;&#39; &lt;collElement&gt;+ &lt;eol&gt;
&lt;collElement&gt; := &quot;[&quot; &lt;alt&gt; &lt;char&gt; &quot;.&quot; &lt;char&gt; &quot;.&quot; &lt;char&gt; (&quot;.&quot; &lt;char&gt;)* &quot;]&quot;
&lt;alt&gt;         := &quot;*&quot; | &quot;.&quot;</pre>
	<p>In the Default Unicode Collation Element Table, the comment may contain informative 
	tags.</p>
	<p>Here are some selected entries taken from a particular version of the data 
	file. (It may not match the actual values in the current data file.)</p>
	<pre>0020 ; [*0209.0020.0002.0020] % SPACE
02DA ; [*0209.002B.0002.02DA] % RING ABOVE; COMPATSEQ
0041 ; [.06D9.0020.0008.0041] % LATIN CAPITAL LETTER A
3373 ; [.06D9.0020.0017.0041] [.08C0.0020.0017.0055] % SQUARE AU; COMPATSEQ
00C5 ; [.06D9.002B.0008.00C5] % LATIN CAPITAL LETTER A WITH RING ABOVE; CANONSEQ
212B ; [.06D9.002B.0008.212B] % ANGSTROM SIGN; CANONSEQ
0042 ; [.06EE.0020.0008.0042] % LATIN CAPITAL LETTER B
0043 ; [.0706.0020.0008.0043] % LATIN CAPITAL LETTER C
0106 ; [.0706.0022.0008.0106] % LATIN CAPITAL LETTER C WITH ACUTE; CANONSEQ
0044 ; [.0712.0020.0008.0044] % LATIN CAPITAL LETTER D</pre>
	<p>The entries in each file are ordered by collation element, not by character, 
	using a SHIFTED comparison. This makes it easy to see the order in which characters 
	would be collated.</p> 
	<p>Although this document describes collation elements as three 
	levels, the file contains a fourth level (as in <tt>[.0712.0020.0008.<b>0044</b>]</tt>),
	which is computable. In most cases the fourth level is
	simply equal to the code point itself. For composite characters which have
	have collation weights using a sequence of collation elements, the fourth level 
	for each collation element is based on the decomposition
	of the character. For completely ignorable collation elements, the fourth level
	is set to zero. For more information on the use
	of the fourth level and stable sorts, see <i>Section 
	3.4, <a href="#Stability">Stability</a></i>.</p>
	<p>Implementations can also add more customizable levels, as discussed above 
	under conformance. For example, an implementation might want to be capable not 
	only of handling the standard Unicode Collation, but also capable of emulating 
	an EBCDIC multi-level ordering (having a fourth-level EBCDIC binary order).
	</p>
	
	<h4><a name="3.2.2_Variable_Collation_Elements"></a>3.2.2
	<a name="Variable_Weighting">Variable Weighting</a></h4>
	
	<p>Collation elements that are marked with an asterisk in a Unicode Collation 
	Element Table are known as <i>variable collation elements.</i></p>
	<table class="wide">
		<tr>
			<th align="LEFT" width="15%">
			<p align="LEFT">Character</p>
			</th>
			<th align="LEFT" width="30%">
			<p align="LEFT">Collation Element</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Name</p>
			</th>
		</tr>
		<tr>
			<td><tt>0020 &quot; &quot;</tt></td>
			<td><tt>[*0209.0020.0002]</tt></td>
			<td>SPACE</td>
		</tr>
	</table>
	<p>Based on the setting of the variable weighting tag, collation elements can 
	be either treated as ignorables or not. When they are treated as ignorables, 
	then any sequence of ignorable characters that immediately follows the variable 
	collation element is also affected.</p>
	<p>There are three possible options for variable weighted characters:</p>
	<ul>
		<li><b>Blanked:</b> Variable collation elements and any subsequent ignorables 
		are reset so that their weights at levels one through three are zero. For 
		example,
		<ul>
			<li><i>SPACE</i> would have the value <tt>[.0000.0000.0000]</tt>
			</li>
			<li>A combining grave accent after a space would have the value <tt>
			[.0000.0000.0000]</tt></li>
			<li><i>Capital A</i> would be unchanged, with the value <tt>[.06D9.0020.0008]</tt>
			</li>
			<li>A combining grave accent after a <i>Capital A </i>would be unchanged</li>
		</ul>
		</li>
		<li><b>Non-ignorable: </b>Variable collation elements are not reset to be ignorable, 
		but get the weights explicitly mentioned in the file.
		<ul>
			<li><i>SPACE </i>would have the value <tt>[.0209.0020.0002]</tt>
			</li>
			<li><i>Capital A</i> would be unchanged, with the value <tt>[.06D9.0020.0008]</tt>
			</li>
			<li>Ignorables are unchanged.</li>
		</ul>
		</li>
		<li><b>Shifted:</b> Variable collation elements are reset 
		to zero at 
		levels one through three. In addition, a new fourth-level weight is appended, 
		whose value depends on the type:<br>
&nbsp;
		<div align="center">
			<center>
			<table class="values">
				<tr>
					<th>Type</th>
					<th>L4</th>
					<th>Examples</th>
				</tr>
				<tr>
					<td>Tertiary Ignorable</td>
					<td>0000</td>
					<td>NULL<br>
					<tt>[.0000.0000.0000.0000]</tt></td>
				</tr>
				<tr>
					<td>Primary or Secondary Ignorable,<br>
					following a Variable</td>
					<td>0000</td>
					<td>COMBINING GRAVE<br>
					<tt>[.0000.0000.0000.0000]</tt></td>
				</tr>
				<tr>
					<td>Variable</td>
					<td>old L1</td>
					<td>SPACE<br>
					<tt>[.0000.0000.0000.0209]</tt></td>
				</tr>
				<tr>
					<td>None of the above</td>
					<td>FFFF</td>
					<td><i>Capital A</i><br>
					<tt>[.06D9.0020.0008.FFFF]</tt></td>
				</tr>
			</table>
			</center></div>
		<p>Any subsequent primary or secondary ignorables following a variable are reset so that their weights at levels one 
		through four are zero.</p>
		<ul>
			<li>A combining grave accent after a space would have the value <tt>
			[.0000.0000.0000.0000]</tt>.</li>
			<li>A combining grave accent after a <i>Capital A </i>would be unchanged.</li>
		</ul>
		<p>The <i>shifted</i> option provides for improved orderings when the variable 
		collation elements are ignorable, while still only requiring three fields 
		to be stored in memory for each collation element. It does result in somewhat 
		longer sort keys, although they can be compressed (see <i>
		Section 6.1, <a href="#Reducing_Sort_Key_Lengths">Reducing Sort Key Lengths</a></i> 
		and Section 6.3, <i><a href="#Reducing_Table_Sizes">Reducing Table Sizes)</a></i>.</p>
		</li>
		<li >A fourth possible option would be <b>Shift-Trimmed:</b> the same as <b>Shifted</b>, except that all trailing 
		FFFFs are trimmed from the sort key. This could be used to emulate 
		POSIX behavior.</li>
	</ul>
	<p>The following gives an example of the differences between orderings 
	using the different options for variable collation elements. In this example, 
	sample strings differ by the third character: a letter, <i>space,</i> &#39;-&#39; <i>
	hyphen-minus (002D)</i>, or &#39;-&#39; <i>hyphen (2010);</i> followed by an uppercase/lowercase 
	distinction. In the first column below, the words with <i>hyphen-minus</i> and
	<i>hyphen</i> are separated by <i>deluge,</i> because an <i>l</i> comes between 
	them in Unicode code order. In the second column, they are grouped together 
	but before all letters in the third position. This is because they are no longer 
	ignorable, and have primary values that differ from the letters. In the third 
	column, the <i>hyphen-minus</i> and <i>hyphen</i> are grouped together, and 
	their differences are less significant than between the deluge. In this case, 
	it is because they are ignorable, but their fourth level differences are according 
	to the original primary order, which is more intuitive than Unicode order.</p>
	<div align="center">
		<table class="example">
			<tr>
				<th style="text-align: center" width="25%">
				<p>Blanked</p>
				</th>
				<th style="text-align: center" width="25%">
				<p>Non-<br>
				ignorable</p>
				</th>
				<th style="text-align: center" width="25%">
				<p>Shifted</p>
				</th>
				<th style="text-align: center" width="25%">
				<p>Shift-<br>
				Trimmed</p>
				</th>
			</tr>
			<tr>
				<td>
				<p>death<br>
				<font color="#0000FF">de luge<br>
				de-luge</font><br>
				deluge<br>
				<font color="#0000FF">de-luge<br>
				de Luge<br>
				de-Luge</font><br>
				deLuge<br>
				<font color="#0000FF">de-Luge</font><br>
				demark</p>
				</td>
				<td>
				<p><font color="#0000FF">de luge<br>
				de Luge<br>
				de-luge<br>
				de-Luge<br>
				de-luge<br>
				de-Luge</font><br>
				death<br>
				deluge<br>
				deLuge<br>
				demark</p>
				</td>
				<td>
				<p>death<br>
				<font color="#0000FF">de luge<br>
				de-luge<br>
				de-luge</font><br>
				deluge<br>
				<font color="#0000FF">de Luge<br>
				de-Luge<br>
				de-Luge<br>
				deLuge</font><br>
				demark</p>
				</td>
				<td>
				<p>death<br>
				deluge<br>
				<font color="#0000FF">de luge<br>
				de-luge<br>
				de-luge</font><br>
				deLuge<br>
				<font color="#0000FF">de Luge<br>
				de-Luge<br>
				de-Luge</font><br>
				demark</p>
				</td>
			</tr>
		</table>
	</div>
	<p>Primaries for variable collation elements are not <i>interleaved</i> with 
	other primary weights. This allows for more compact storage of memory tables. 
	Rather than using a bit per collation element to determine whether the collation 
	element is variable, the implementation only needs to store the maximum primary 
	value for all the variable elements. All collation elements with primary weights 
	from 1 to that maximum are variables; all other collation elements are not.</p>
	<h3>3.3 <a name="Well-Formed">Well-Formed Collation Element Tables</a></h3>
	<p><a name="ill-formed_definition"></a>A well-formed Collation Element Table 
	meets the following conditions:</p>
	<blockquote>
		<ol>
			<li>Except in special cases detailed in <i>
			Section 6.2, <a href="#Large_Weight_Values">Large Weight Values</a></i>, 
			no collation element can have a zero weight at Level N and a non-zero 
			weight at Level N-1.
			<p>For example, the secondary can only be ignorable if the primary is 
			ignorable. The reason for this will be explained under Step 4 of the 
			main algorithm.</p>
			</li>
			<li>All Level N weights in Level N-1 ignorables must be strictly less 
			than all weights in Level N-2 ignorables.
			<p>For example, secondaries in non-ignorables must be strictly less 
			than those in primary ignorables: </p>
			<ul>
				<li>Given collation elements [C, D, E] and [0, A, B], where C ≠ 
				0 and A ≠ 0</li>
				<li>Then D <i>must be</i> less than A.</li>
			</ul>
			</li>
			<li>No variable collation element has an ignorable primary.</li>
			<li>For all variable collation elements U, V, if there is a collation 
			element W such that U<sub>1</sub> <font size="3">≤</font> W<sub>1</sub> 
			and W<sub>1</sub> <font size="3">≤</font> V<sub>1</sub>, then W is also 
			variable.
			<p>This provision prevents interleaving, mentioned above.</p>
			</li>
		</ol>
	</blockquote>
	<h3>3.4 <a name="Stability">Stability</a></h3>
	<p>The notion of <i>stability</i> in sorting often causes confusion when discussing 
	collation.<br>
	<br>
	A <i>stable sort</i> is one where two records with a field that compares as 
	equal will retain their order if sorted according to that field. This is a property 
	of the sorting algorithm, <i>not</i> the comparison mechanism. For example, 
	a bubble sort is stable, while a quick sort is not. This is a useful property, 
	but cannot be accomplished by modifications to the comparison mechanism or tailorings.<br>
	<br>
	A <i>semi-stable collation</i> is different. It is a collation where strings 
	that are not canonical equivalents will not be judged to be equal. This is a 
	property of comparison, <i>not</i> the sorting algorithm. In general this is 
	not a particularly useful property; its implementation also typically requires 
	extra processing in string comparison or an extra level in sort keys, and thus 
	may degrade performance to little purpose. However, if a semi-stable collation 
	is required, the specified mechanism is to append the NFD form of the original 
	string after the sort key, in <i>Section 4.3, <a href="#Step_3">Form Sort Key</a></i>. 
	See also <i><a href="#Deterministic_Sorting">Appendix A: Deterministic_Sorting</a></i>.</p>
	<p>The fourth-level weights in the Default Collation Element Table can be used 
	to provide an approximation of a semi-stable collation.</p>
	<p>Neither one of the above refers to the stability of the Default Collation 
	Element Table itself. For any particular version of the UCA, the contents of 
	that table will remain unchanged. The contents may, however, change <i>between</i> 
	successive versions of the UCA, as new characters are added, or as more information 
	is obtained about existing characters.</p>
	<p>Implementers should be aware that using different versions of the UCA, as 
	well as different versions of the Unicode Standard, could result in different 
	collation results of their data. There are numerous ways collation data could 
	vary across versions, for example:</p>
	<ol>
		<li>Code points that were unassigned in a previous version of the Unicode 
		Standard are now assigned in the current version, and as such, will have 
		a sorting semantic appropriate to the repertoire to which they belong. For 
		example, the code points U+103D0..U+103DF were undefined in Unicode 3.1. 
		Because they were assigned characters in Unicode 3.2, their sorting semantics 
		and respective sorting weights will change.</li>
		<li>Certain semantics of the Unicode standard could change between versions, 
		such that code points are treated in a manner different than previous versions 
		of the standard (for example, normalization errata).</li>
		<li>More information is gathered about a particular script, and in order 
		to provide a more linguistically accurate sort, the weight of a code point 
		may need to be adjusted.</li>
	</ol>
	<p>Any of these reasons could necessitate a change between versions with regards 
	to sort weights for code points, and as such, it is important that the implementers 
	specify the version of the UCA, as well as the version of the Unicode standard 
	under which their data is sorted.</p>
	<h2><a name="Main_Algorithm"></a>4 Main Algorithm</h2>
	<p>The main algorithm has four steps. First is to normalize each input string, 
	second is to produce an array of collation elements for each string, and third 
	is to produce a sort key for each string from the collation elements. Two sort 
	keys can then be compared with a binary comparison; the result is the ordering 
	for the original strings.</p>
	<h3><a name="Step_1"></a>4.1 Normalize</h3>
	<p><b>Step 1. </b>Produce a normalized form of each input string, applying
	<a href="#S1.1">S1.1</a>.</p>
	<p><b><a name="S1.1">S1.1</a> </b>Use the Unicode canonical algorithm to decompose 
	characters according to the canonical mappings. That is, put the string into 
	Normalization Form D (see [<a href="#UAX15">UAX15</a>]).</p>
	<ul>
		<li>Conformant implementations may skip this step <i>in certain circumstances:
		</i>see <i>Section 7, <a href="#Weight_Derivation">Weight Derivation</a></i> 
		for more information.</li>
	</ul>
	<h3><a name="Step_2"></a>4.2 Produce Array</h3>
	<p><b>Step 2. </b>The collation element array is built by sequencing through 
	the normalized form as follows:</p>
	<blockquote>
		<p><b>Note:</b> A non-starter in a string is called <i>blocked</i> if there 
		is another non-starter of the same canonical combining class or zero between 
		it and the last character of canonical combining class 0.</p>
	</blockquote>
	<p><b><a name="S2.1">S2.1</a> </b>Find the longest initial substring S at each 
	point that has a match in the table. </p>
	<blockquote>
		<p><b><a name="S2.1.1">S2.1.1</a> </b>If there are any non-starters following 
		S, process each non-starter C.</p>
		<p><b><a name="S2.1.2">S2.1.2</a> </b>If C is not blocked from S, find if 
		S + C has a match in the table.</p>
		<p><b><a name="S2.1.3">S2.1.3</a> </b>If there is a match, replace S by 
		S + C, and remove C.</p>
	</blockquote>
	<p><b><a name="S2.2">S2.2</a></b> Fetch the corresponding collation element(s) 
	from the table if there is a match. If there is no match, synthesize a weight 
	as described in <i>Section 7.1, <a href="#Derived_Collation_Elements">Derived 
	Collation Elements</a></i>.</p>
	<p><b><a name="S2.3">S2.3</a> </b>Process collation elements according to the 
	variable-weight setting, as described in <i>
	>Section 3.2.2, <a href="#3.2.2_Variable_Collation_Elements">Variable Weighting</a></i>.</p>
	<p><b><a name="S2.4">S2.4</a></b> Append the collation element(s) to the collation 
	element array.</p>
	<p><b><a name="S2.5">S2.5</a> </b>Proceed to the next point in the string (past 
	S).</p>
	<p><b><a name="S2.6">S2.6</a> </b>Loop until the end of the string is reached.</p>
	<blockquote>
		<p><b>Note:</b> The reason for considering the extra non-starter C is that 
		otherwise irrelevant characters could interfere with matches in the table. 
		For example, suppose that the contraction <i>&lt;a, combining_ring&gt;</i> (=
		<i>å</i>) is ordered after <i>z</i>. If a string consists of the three characters
		<i>&lt;a, combining_ring, combining_cedilla&gt;</i>, then the normalized form 
		is <i>&lt;a, combining_cedilla, combining_ring&gt;</i>, which separates the <i>
		a</i> from the <i>combining_ring</i>. If we did not have the step of considering 
		the extra non-starter, this string would compare incorrectly as after <i>
		a</i> and not after <i>z</i>.</p>
		<p>If the desired ordering treats <i>&lt;a, combining_cedilla&gt;</i> as a contraction 
		which should take precedence over <i>&lt;a, combining_ring&gt;,</i> then an additional 
		mapping for the combination <i>&lt;a, combining_ring, combining_cedilla&gt;</i> 
		can be introduced to produce this effect.</p>
		<p><b>Note:</b> <font color="#000000">For conformance to Unicode canonical 
		equivalence, only unblocked non-starters are matched. For example, <i>&lt;a, 
		combining_macron, combining_ring&gt;</i> would compare as after <i>a-macron</i>, 
		and not after <i>z</i>. As in the previous note, additional mappings can 
		be added to customize behavior.</font></p>
	</blockquote>
	<table class="wide">
		<caption style="text-align:left"><i>Example:</i></caption>
		<tr>
			<td width="15%"><font color="#000000">normalized string:</font></td>
			<td><font color="#000000">ca</font>´<font color="#000000">b</font></td>
		</tr>
		<tr>
			<td><font color="#000000">collation element array:</font></td>
			<td><tt><font color="#000000" size="-1">[0706.0020.0002], [06D9.0020.0002], 
			[0000.0021.0002], [06EE.0020.0002]</font></tt></td>
		</tr>
	</table>
	<p>&nbsp;<br>
	</p>
	<h3><a name="Step_3"></a>4.3 Form Sort Key</h3>
	<p><b>Step 3. </b>The sort key is formed by successively appending weights from 
	the collation element array. The weights are appended from each level in turn, 
	from 1 to 3. (Backwards weights are inserted in reverse order.)</p>
	<p>An implementation may allow the <i>maximum level</i> to be set to a smaller 
	level than the available levels in the collation element array. For example, 
	if the maximum level is set to 2, then level 3 and higher weights are not appended 
	to the sort key. Thus any differences at levels 3 and higher will be ignored, 
	leveling any such differences in string comparison.</p>
	<p>Here is a more detailed statement of the algorithm:</p>
	<p><b><a name="S3.1">S3.1</a> </b>For each weight level L in the collation element 
	array from 1 to the maximum level, </p>
	<blockquote>
		<p><b><a name="S3.2">S3.2</a> </b>If L is not 1, append a <i>level separator*</i></p>
		<p><b><a name="S3.3">S3.3</a> </b>If the collation element table is forwards 
		at level L,</p>
		<blockquote>
			<p><b><a name="S3.4">S3.4</a> </b>For each collation element CE in the 
			array</p>
			<blockquote>
				<p><b><a name="S3.5">S3.5</a> </b>Append CE<sub>L</sub> to the sort 
				key if CE<sub>L</sub> is non-zero.</p>
			</blockquote>
		</blockquote>
		<p><b><a name="S3.6">S3.6</a> </b>Else the collation table is backwards 
		at level L, so</p>
		<blockquote>
			<p><b><a name="S3.7">S3.7</a> </b>Form a list of all the non-zero CE<sub>L</sub> 
			values.</p>
			<p><b><a name="S3.8">S3.8</a> </b>Reverse that list</p>
			<p><b><a name="S3.9">S3.9</a> </b>Append the CE<sub>L</sub> values from 
			that list to the sort key.</p>
		</blockquote>
	</blockquote>
	<blockquote>
		<p><b>* </b>The level separator is zero (0000), which is guaranteed to be 
		lower than any weight in the resulting sort key. This guarantees that when 
		two strings of unequal length are compared, where the shorter string is 
		a prefix of the longer string, the longer string is always sorted after 
		the shorter (in the absence of special features like contractions). For 
		example:</p>
	</blockquote>
	<p align="center">&quot;abc&quot; &lt; &quot;abcX&quot; where &quot;X&quot; can be any character(s)</p>
	<p><b><a name="S3.10">S3.10</a></b> If a semi-stable sort is required, then 
	after all the level weights have been added, append a copy of the NFD version 
	of the original string. This strength level is called &quot;identical&quot;. (See also
	<i><a href="#Deterministic_Sorting">Appendix A: Deterministic_Sorting</a></i>.)</p>
	<blockquote>
		<table class="wide">
			<caption style="text-align:left"><i>Example:</i></caption>
			<tr>
				<td width="15%">collation element array:</td>
				<td><tt>[0706.0020.0002], [06D9.0020.0002], [0000.0021.0002], [06EE.0020.0002]</tt></td>
			</tr>
			<tr>
				<td>sort key:</td>
				<td><tt>0706 06D9 06EE 0000 0020 0020 0021 0020 0000 0002 0002 0002 
				0002</tt></td>
			</tr>
		</table>
	</blockquote>
	<p>&nbsp;&nbsp; </p>
	<h3><a name="Step_4"></a>4.4 Compare</h3>
	<p><b>Step 4. </b>Compare the sort keys for each of the input strings, using 
	a binary comparison. This means that:</p>
	<ul>
		<li>Level 3 differences are ignored if there are any Level 1 or 2 differences
		</li>
		<li>Level 2 differences are ignored if there are any Level 1 differences
		</li>
		<li>Level 1 differences are never ignored. </li>
	</ul>
	<blockquote>
		<table class="wide">
			<caption style="text-align:left"><i>Example:</i></caption>
			<tr>
				<th align="LEFT">
				<p align="LEFT">String</p>
				</th>
				<th align="LEFT">
				<p align="LEFT">Sort Key</p>
				</th>
			</tr>
			<tr>
				<td><font color="#000000">cab</font></td>
				<td><tt><u><b><font color="#ff9c05">0706</font></b></u> 06D9 06EE 
				0000 0020 0020 <u><b><font color="#00ba00">0020</font></b></u> 0000
				<u><b><font color="#0099ff">0002</font></b></u> 0002 0002</tt></td>
			</tr>
			<tr>
				<td>Cab</td>
				<td><tt><u><b><font color="#ff9c05">0706</font></b></u> 06D9 06EE 
				0000 0020 0020 <u><b><font color="#00ba00">0020</font></b></u> 0000
				<u><b><font color="#0099ff">0008</font></b></u> 0002 0002</tt></td>
			</tr>
			<tr>
				<td>cáb</td>
				<td><tt><u><b><font color="#ff9c05">0706</font></b></u> 06D9 06EE 
				0000 0020 0020 <u><b><font color="#00ba00">0021</font></b></u> 0020 
				0000 0002 0002 0002 0002</tt></td>
			</tr>
			<tr>
				<td>dab</td>
				<td><tt><u><b><font color="#ff9c05">0712</font></b></u> 06D9 06EE 
				0000 0020 0020 0020 0000 0002 0002 0002</tt></td>
			</tr>
		</table>
	</blockquote>
	<p>In this example, &quot;cab&quot; &lt;<sub>3</sub> &quot;Cab&quot; &lt;<sub>2</sub> &quot;cáb&quot; &lt;<sub>1</sub> 
	&quot;dab&quot;. The differences that produce the ordering are shown by the <u><b>bold 
	underlined</b></u> items:</p>
	<ul>
		<li>For the first two strings, the first difference is in <b><tt>
		<font color="#0099ff">0002</font></tt></b> versus <b><tt>
		<font color="#0099ff">0008</font></tt></b> (Level 3) </li>
		<li>For the middle two strings the first difference is in <b><tt>
		<font color="#00ba00">0020</font></tt></b> versus <b><tt>
		<font color="#00ba00">0021</font></tt></b> (Level 2) </li>
		<li>For the last two strings, the first difference is in <b><tt>
		<font color="#ff9c05">0706</font></tt></b> versus <b><tt>
		<font color="#ff9c05">0712</font></tt></b> (Level 1). </li>
	</ul>
	<blockquote>
		<p><b>Note:</b> <a name="ill-formed_reason"></a>At this point we can explain 
		the reason for only allowing <a href="#ill-formed_definition">well-formed 
		weights</a>. If ill-formed weights were allowed, the ordering of elements 
		can be incorrectly reflected in the sort key. For example, suppose the secondary 
		weights of the Latin characters were zero (ignorable) and that (as normal) 
		the primary weights of case-variants are equal: that is, <i>a<sub>1</sub> 
		= A<sub>1</sub>.</i> Then the following incorrect keys would be generated:</p>
		<ol>
			<li><i>&quot;áe&quot; = &lt;a, acute, e&gt; =&gt; [a<sub>1</sub> e<sub>1</sub> 0000 acute<sub>2</sub> 
			0000 <u><b>a<sub>3</sub></b></u> acute<sub>3</sub> e<sub>3</sub>...]</i>
			</li>
			<li><i>&quot;Aé&quot; = &lt;A, e, acute&gt; =&gt; [a<sub>1</sub> e<sub>1</sub> 0000 acute<sub>2</sub> 
			0000 <u><b>A<sub>3</sub></b></u> acute<sub>3</sub> e<sub>3</sub>...]</i>
			</li>
		</ol>
		<p>Because the secondary weights for <i>a, A, </i>and<i> e</i> are lost 
		in forming the sort key, the relative order of the acute is also lost, resulting 
		in an incorrect ordering based solely on the case of <i>A</i> versus <i>
		a</i>. With well-formed weights, this does not happen, and you get the following 
		correct ordering:</p>
		<ol>
			<li><i>&quot;Aé&quot; = &lt;A, e, acute&gt; =&gt; [a<sub>1</sub> e<sub>1</sub> 0000 a<sub>2</sub>
			<u><b>e<sub>2</sub></b></u> acute<sub>2</sub> 0000 a<sub>3</sub> acute<sub>3</sub> 
			e<sub>3</sub>...]</i> </li>
			<li><i>&quot;áe&quot; = &lt;a, acute, e&gt; =&gt; [a<sub>1</sub> e<sub>1</sub> 0000 a<sub>2</sub>
			<u><b>acute<sub>2</sub></b></u> e<sub>2</sub> 0000 A<sub>3</sub> acute<sub>3</sub> 
			e<sub>3</sub>...]</i> </li>
		</ol>
		<p>However, there are circumstances--typically in expansions--where higher-level 
		weights in collation elements can be zeroed (resulting in ill-formed collation 
		elements) without consequence (see <i>Section 
		6.2, <a href="#Large_Weight_Values">Large Weight Values</a></i>). Implementations are free to do this as 
		long as they produce the same result as with well-formed tables.</p>
	</blockquote>
	
	<h2><a name="Tailoring"></a>5 Tailoring</h2>
	
	<p>Tailoring is any well-defined syntax that takes the Default 
	Unicode Collation Element Table and produces another well-formed Unicode Collation 
	Element Table. This syntax can provide linguistically-accurate collation, if 
	desired. Such syntax will usually allow for the following capabilities:</p>
	<ol>
		<li>
		<p>Reordering any character (or contraction) with respect to 
		others in the standard ordering. Such a reordering can represent a Level 
		1 difference, Level 2 difference, Level 3 difference, or identity (in levels 
		1 to 3). Because such reordering includes sequences, arbitrary multiple 
		mappings can be specified. </p>
		</li>
		<li>
		<p>Setting the secondary level to be backwards (French) or 
		forwards (normal). </p>
		</li>
		<li>
		<p>Set variable weighting options. </p>
		</li>
		<li>
		<p>Customizing the exact list of variable collation elements.</p>
		</li>
	</ol>

	<p>For best interoperability, it is recommended that tailorings for
	particular locales (or languages) make use of the tables provided in
	the Unicode Common Locale Data Repository [<a href="#CLDR">CLDR</a>].</p>
	
	<p>For examples of tailoring syntax, see <i>
	Section 6.9, <a href="#Comparison_to_Java">Tailoring Example: Java</a></i>.</p>
	
	<h3>5.1 <a name="Parametic_Tailoring">Parametric Tailoring</a></h3>
	
	<p>Parametric tailoring, if supported, is specified using a set 
	of attribute-value pairs that specify a particular kind of behavior relative 
	to the UCA. The standard parameter names (attributes) and their posible values 
	are listed in the table <b>Collation Parameters</b>, and follow those defined 
	in the Unicode <i>Locale Data Markup Language</i> [<a href="#LDML">LDML</a>] 
	in the table <i>Collation Settings</i> (<i>Section 5.13.3,
	<a href="http://unicode.org/reports/tr35/#Collation_Elements">Setting Options</a></i>). 
	The bold values are the defaults for the UCA.</p>
	<table style="margin-top: 1.5em; margin-bottom: 0.5em" id="table11">
		<caption><a name="Collation_Settings">Collation Parameters</a></caption>
		<tr>
			<th>Attribute</th>
			<th>Options</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>locale&nbsp; (or language)</td>
			<td><i>locale_id</i></td>
			<td>Specifies the tailoring rules for the language and/or variant. The 
			locale_id for locale or language uses the syntax from [<a href="#LDML">LDML</a>],
			<i>Section 3, <a href="http://unicode.org/reports/tr35/#Identifiers">
			Identifiers</a></i>. Unless otherwise specified, tailoring by locale 
			uses the tables from the Unicode <i>Common Locale Data Repository</i> 
			[<a href="#CLDR">CLDR</a>]. Such a choice may override the defaults 
			for the attributes given below. The default if nothing is specified 
			is the UCA behavior.</td>
		</tr>
		<tr>
			<td><font color="#000000">strength</font></td>
			<td>primary (1)<br>
			secondary (2)<br>
			<b>tertiary</b> (3)<br>
			quaternary (4)<br>
			identical (5)</td>
			<td>Sets the default strength for comparison, as described in the UCA. 
			The parenthesized numbers are alternate forms.</td>
		</tr>
		<tr>
			<td>alternate</td>
			<td>non-ignorable<br>
			<b>shifted</b><br>
			<i>blanked</i></td>
			<td>Sets alternate handling for variable weights, as described in
			Section 3.2.2, <a href="#3.2.2_Variable_Collation_Elements">Variable 
			Weighting</a>. Note that in [<a href="#LDML">LDML</a>], <i>blanked</i> 
			is not supported, and <b>shifted</b> is the default.</td>
		</tr>
		<tr>
			<td>backwards</td>
			<td>on<br>
			<b>off</b></td>
			<td>Sets the comparison for the second level<i> only </i>to be backwards 
			(&quot;French&quot;), as described in 3.1.2 <a href="#French_Accents">French Accents</a> 
			and specified in <a href="#S3.3">S3.3</a>-<a href="#S3.6">S3.6</a>. 
			The default is <b>on</b> for the French locales and <b>off</b> for others.</td>
		</tr>
		<tr>
			<td>normalization</td>
			<td><b>on</b><br>
			off</td>
			<td>Conformant implementations may skip [<b><a name="S1.2">S1.1</a>]</b> 
			in certain circumstances. If <i>on</i>, then the normal UCA algorithm 
			is used. If <i>off</i>, all strings that normalized will sort correctly, 
			but others won&#39;t necessarily sort correctly. So it should only be set
			<i>off</i> if the the strings to be compared are normalized. (It is 
			recommended that implementations correctly sort all strings that are 
			in the format known as <i>FCD</i> even if normalization is <i>off</i>. 
			For more information on FCD, see [UTN5].)</td>
		</tr>
		<tr>
			<td>caseLevel</td>
			<td>on<br>
			<b>off</b></td>
			<td>If set to <i>on,</i> a level consisting only of case characteristics 
			will be inserted in front of tertiary level. To ignore accents but take 
			cases into account, set strength to primary and case level to <i>on</i>.
			</td>
		</tr>
		<tr>
			<td>caseFirst</td>
			<td>upper<br>
			lower<br>
			<b>off</b></td>
			<td>If set to <i>upper</i>, causes upper case to sort before lower case. 
			If set to <i>lower</i>, lower case will sort before upper case. Useful 
			for locales that have already supported ordering but require different 
			order of cases. Affects case and tertiary levels.</td>
		</tr>
		<tr>
			<td>hiraganaQuaternary</td>
			<td>on<br>
			<b>off</b></td>
			<td>Controls special treatment of Hiragana code points on quaternary 
			level. If turned <i>on</i>, Hiragana codepoints will get lower values 
			than all the other non-variable code points. The strength must be greater 
			or equal than quaternary if you want this attribute to take effect. 
			The default is <b>on</b> for the Japanese locales and <b>off</b> for 
			others.</td>
		</tr>
		<tr>
			<td>numeric</td>
			<td>on<br>
			<b>off</b></td>
			<td>If set to <i>on</i>, any sequence of Decimal Digits (General_Category 
			= Nd in the Unicode Character Database [<a href="#UAX44">UAX44</a>]) is sorted at a primary level with 
			its numeric value. For example, &quot;A-21&quot; &lt; &quot;A-123&quot;.</td>
		</tr>
		<tr>
			<td>variableTop</td>
			<td><i>uXXuYYYY</i></td>
			<td>The parameter value is an encoded Unicode string, with code points 
			in hex, leading zeros removed, and &#39;u&#39; inserted between successive elements.<p>
			Sets the default value for the variable top. All the code points with 
			primary strengths less than variable top will be considered variable, 
			and thus affected by the alternate handling. If not specified, then 
			the default is the value in DUCET.</p>
			</td>
		</tr>
		<tr>
			<td>match-boundaries:</td>
			<td nowrap>none<br>
			whole-character<br>
			whole-word</td>
			<td>Defined in <i>Section 8, <a href="#Searching">Searching and Matching</a>.</i></td>
		</tr>
		<tr>
			<td>match-style</td>
			<td>minimal<br>
			medial<br>
			maximal</td>
			<td>Defined in <i>Section 8, <a href="#Searching">Searching and Matching</a>.</i></td>
		</tr>
	</table>
	<p>&nbsp;</p>
	
	<h3><a name="Preprocessing"></a>5.2 Preprocessing</h3>
	
	<p>In addition to tailoring, some implementations may choose to 
	preprocess the text for special purposes. Once such preprocessing is done, the 
	standard algorithm can be applied.</p>
	<p>Examples include:</p>
	<ul>
		<li>
		<p>mapping &quot;McBeth&quot; to &quot;MacBeth&quot;</p>
		</li>
		<li>
		<p>mapping &quot;St.&quot; to &quot;Street&quot; or &quot;Saint&quot;, depending on the context
		</p>
		</li>
		<li>
		<p>dropping articles, such as <i>a</i> or <i>the</i></p>
		</li>
		<li>
		<p>using extra information, such as pronunciation data for 
		Han characters</p>
		</li>
	</ul>
	<p>Such preprocessing is outside of the scope of this document.</p>
	
	<h2><a name="Implementation_Notes"></a>6 Implementation Notes</h2>
	
	<p>As noted above for efficiency, implementations may vary from 
	this logical algorithm as long as they produce the same result. The following 
	items discuss various techniques that can be used for reducing sort key length, 
	reducing table sizes, customizing for additional environments, searching, and 
	other topics.</p>
	
	<h3><a name="Reducing_Sort_Key_Lengths"></a>6.1 Reducing Sort Key Lengths</h3>
	
	<p>The following discuss methods of reducing sort key lengths. 
	If these methods are applied to all of the sort keys produced by an implementation, 
	they can result in significantly shorter and more efficient sort keys while 
	retaining the same ordering.</p>
	
	<h4>6.1.1 <a name="Eliminating_level_separators">Eliminating Level Separators</a></h4>
	
	<p>Level separators are not needed between two levels in the sort key, if the 
	weights are properly chosen. For example, if all L3 weights are less than all 
	L2 weights, then no level separator is needed between them. If there is a fourth 
	level, then the separator before it needs to be retained.</p>
	<p>For example, here is a sort key with these level separators removed.</p>
	<table class="wide">
		<tr>
			<th align="LEFT">
			<p align="LEFT">String</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Sort Key</p>
			</th>
		</tr>
		<tr>
			<td width="15%">càb (0)</td>
			<td><tt>0706 06D9 06EE <b>0000</b> 0020 0020 0021 0020 <b>0000</b> 0002 
			0002 0002 0002</tt></td>
		</tr>
		<tr>
			<td>càb (1)</td>
			<td><tt>0706 06D9 06EE 0020 0020 0021 0020 0002 0002 0002 0002</tt></td>
		</tr>
	</table>
	<p>While this technique is relatively easy to implement, it can interfere with 
	other compression methods.</p>
	<h4>6.1.2 <a name="L2/L3_in_8_bits">L2/L3 in 8 Bits</a></h4>
	<p>The L2 and L3 weights commonly are small values. Where that condition occurs 
	for all possible values, they can then be represented as single 8-bit quantities.</p>
	<p>Here is the above example with both these changes (and grouping by bytes). 
	Note that the separator has to remain after the primary weight when combining 
	these techniques. If any separators are retained (such as before the fourth 
	level), they need to have the same width as the previous level.</p>
	<table class="wide">
		<tr>
			<th align="LEFT">
			<p align="LEFT">String</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Sort Key</p>
			</th>
		</tr>
		<tr>
			<td width="15%">càb (0)</td>
			<td><tt>07 06 06 D9 06 EE <b>00 00</b> 00 20 00 20 00 21 00 20 00 00 
			00 02 00 02 00 02 00 02</tt></td>
		</tr>
		<tr>
			<td>càb (1,2)</td>
			<td><tt>07 06 06 D9 06 EE <b>00 00</b> 20 20 21 20 02 02 02 02</tt></td>
		</tr>
	</table>
	<p><br>
	</p>
	<h4>6.1.3 <a name="Machine_Words">Machine Words</a></h4>
	<p>The sort key can be represented as an array of different quantities depending 
	on the machine architecture. For example, comparisons as arrays of 32-bit quantities 
	may be much faster on some machines. If this is done, the original is to be 
	padded with trailing (not leading) zeros as necessary.</p>
	<table class="wide">
		<tr>
			<th align="LEFT">
			<p align="LEFT">String</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Sort Key</p>
			</th>
		</tr>
		<tr>
			<td width="15%">càb (1,2)</td>
			<td><tt>07 06 06 D9 06 EE 00 00 20 20 21 20 02 02 02 02</tt></td>
		</tr>
		<tr>
			<td>càb (1,2,3)</td>
			<td><tt>070606D9 06EE0000 20202120 02020202</tt></td>
		</tr>
	</table>
	<h4>&nbsp;</h4>
	<h4>6.1.4 <a name="Run-length_Compression">Run-Length Compression</a></h4>
	<p>Generally sort keys do not differ much in the secondary or tertiary weights, 
	so you tend to end up with keys with a lot of repetition. This also occurs with 
	quaternary weights generated with the shifted parameter. By the structure of 
	the collation element tables, there are also many weights that are never assigned 
	at a given level in the sort key. You can take advantage of these regularities 
	in these sequences to compact the length — while retaining the same sort sequence 
	— by using the following technique. (There are other techniques that can also 
	be used.)</p>
	<p>This is a logical statement of the process: the actual implementation can 
	be much faster and performed as the sort key is being generated.</p>
	<ul>
		<li>For each level <b><i>n, </i></b>find the most common value COMMON produced 
		at that level by the collation element table for typical strings. For example, 
		for the Default Unicode Collation Element Table, this is:
		<ul>
			<li>0020 for the secondaries (corresponding to unaccented characters)
			</li>
			<li>0002 for tertiaries (corresponding to lowercase or unmarked letters)
			</li>
			<li>FFFF for quaternaries (corresponding to non-ignorables with the 
			shifted parameter) </li>
		</ul>
		</li>
		<li>Reassign the weights in the collation element table at level <b><i>n</i></b> 
		to create a gap of size GAP above COMMON. Typically for secondaries or tertiaries 
		this is done after the values have been reduced to a byte range by the above 
		methods. Here is a mapping that moves weights up or down to create a gap 
		in a byte range.<br>
		<tt>w -&gt; w + 01 - MIN, for MIN &lt;= w &lt; COMMON<br>
		w -&gt; w + FF - MAX, for COMMON &lt; w &lt;= MAX</tt> </li>
		<li>At this point, weights go from 1 to MINTOP, and from MAXBOTTOM to MAX. 
		These new unassigned values are used to run-length encode sequences of COMMON 
		weights. </li>
		<li>When generating a sort key, look for maximal sequences of <b>m</b> COMMON 
		values in a row. Let W be the weight right after the sequence.
		<ul>
			<li>If W &lt; COMMON (or there is no W), replace the sequence by a synthetic 
			low weight equal to (MINTOP + m). </li>
			<li>If W &gt; COMMON, replace the sequence by a synthetic high weight equal 
			to (MAXBOTTOM - m). </li>
		</ul>
		<p>In the following example, the low weights are 01, 02; the high weights 
		are FE, FF; and the common weight is 77. </p>
		</li>
	</ul>
	<p align="center"><i>Examples</i></p>
	<div align="center">
		<center>
		<table class="example">
			<tr>
				<th align="LEFT" width="50%">
				<p align="center">Original Weights</p>
				</th>
				<th align="LEFT" width="50%">
				<p align="center">Compressed Weights</p>
				</th>
			</tr>
			<tr>
				<td width="50%">
				<pre>01
02
77 01
77 02
77 77 01
77 77 02
77 77 77 01
77 77 77 02
...
77 77 77 FE
77 77 77 FF
77 77 FE
77 77 FF
77 FE
77 FF
FE
FF</pre>
				</td>
				<td width="50%">
				<pre>01
02
03 01
03 02
04 01
04 02
05 01
05 02
...
FB FE
FB FF
FC FE
FC FF
FD FE
FD FF
FE
FF</pre>
				</td>
			</tr>
		</table>
		</center></div>
	<ul>
		<li>The last step is a bit too simple, because we have to keep the synthetic 
		weights from colliding with other values with long strings of COMMON weights. 
		This is done by using a sequence of synthetic weights, absorbing as much 
		length into each one as possible. This is done by defining a value BOUND 
		between MINTOP and MAXBOTTOM. The exact value for BOUND can be chosen based 
		on the expected frequency of synthetic low weights versus high weights for 
		the particular collation element table.
		<ul>
			<li>If a synthetic low weight would not be less than BOUND, use a sequence 
			of low weights of the form (BOUND-1)..(BOUND-1)(MINTOP + remainder) 
			to express the length of the sequence. </li>
			<li>Similarly, if a synthetic high weight would be less than BOUND, 
			use a sequence of high weights of the form (BOUND)..(BOUND)(MAXBOTTOM 
			- remainder). </li>
		</ul>
		</li>
	</ul>
	<p>This process results in keys that are never longer than the original, are 
	generally much shorter, and result in the same comparisons.</p>
	<h3><a name="Large_Weight_Values"></a>6.2 Large Weight Values</h3>
	<p><a name="ill-formed_example"></a>If a collation sequence requires more than 
	65,535 weight values (or 65,024 values where zero bytes are avoided), this can 
	still be accommodated by using multiple collation elements for a single character. 
	For example, suppose that 50,000 UTF-16 supplementary characters are assigned 
	in a particular implementation, and that these are to be sorted after X. Simply 
	assign them all dual collation elements of the form</p>
	<blockquote>
		<p><code>[(X<sub>1</sub>+1).0000.0000], [yyyy.zzzz.wwww]</code> </p>
	</blockquote>
	<p>If there was an element with the primary weight <code>(X<sub>1</sub>+1)</code>, 
	then it also needs to be converted into a dual collation element.</p>
	<p>The characters will then sort properly with respect to each other and to 
	the rest of the characters. The first collation element is one of the instances 
	where ill-formed collation elements are allowed. Because the second collation 
	element is well-formed and the first element will only occur in combination, 
	ordering is preserved.</p>
	<h3><a name="Reducing_Table_Sizes"></a>6.3 Reducing Table Sizes</h3>
	<p>The data tables required for full Unicode sorting can be quite sizable. This 
	section discusses ways to significantly reduce the table size in memory. These 
	have very important implications for implementations.</p>
	<h4>6.3.1 <a name="Contiguous_weight_ranges">Contiguous Weight Ranges</a></h4>
	<p>The Default Unicode Collation Element Table has secondary weights that are 
	greater than 00FF. This is the result of the derivation described in <i>
	Section 7, <a href="#Weight_Derivation">Weight Derivation</a></i>. However, 
	these values can be compacted to a range of values that do not exceed 00FF. 
	Whenever collation elements have different primary weights, the ordering of 
	their secondary weights is immaterial. Thus all of the secondaries that share 
	a single primary can be renumbered to a contiguous range without affecting the 
	resulting order. Composite characters still need to be handled correctly if 
	normalization is avoided as discussed in <i>Section 
	7, <a href="#Weight_Derivation">Weight Derivation</a></i>.</p>
	<p>For example, for the primary value 0820 (for the letter O), there are 31 
	distinct secondary values ranging from 0020 to 012D. These can be renumbered 
	to the contiguous range from 0020 to 003F, which is less than 00FF.</p>
	
	<h4>6.3.2 <a name="Escape_hatch">Escape Hatch</a></h4>
	
	<p>Although the secondary and tertiary weights for the Default Unicode Collation 
	Element Table can both fit within one byte, of course, any particular tailored 
	table could conceivably end up with secondary or tertiary weights that exceed 
	what can be contained in a single byte. However, the same technique used for 
	large weight values can also be used for implementations that do not want to 
	handle more than 00FF values for a particular weight.</p>
	<p>For example, the Java collation implementation only stored 8-bit quantities 
	in level 2 and level 3. However, characters can be given L2 or L3 weights with 
	greater values by using a series of two collation elements. For example, with 
	characters requiring 2,000 weights at L2, then 248 characters can be given single 
	keys, while 1,752 (2000 - 248) are given two collation keys of the form [yyyy.00zz.00ww] 
	[0000.00nn.0001].</p>
	<p>The 248 can be chosen to be the higher frequency characters, while there 
	would need to be eight distinct zz values to cover the remaining characters. 
  These zz values must only be used with dual collation elements.</p>
	<h4>6.3.3 <a name="Leveraging_Unicode_tables">Leveraging Unicode Tables</a></h4>
	<p>Because all canonically decomposable characters are decomposed in Step 1.1, 
	no collation elements need to be supplied for them. This includes a very large 
	number of characters, not only a large number of Latin and Greek characters, 
	but also the very large number of Hangul Syllables.</p>
	<p>Because most compatibility decomposable characters in the default table can 
	be algorithmically generated from the decomposition, no collation elements need 
	to be stored for those decomposable characters: the collation elements can be 
	generated on the fly with only a few exceptions entered in the table. The collation 
	elements for the Han characters (unless tailored) are algorithmically derived; 
	no collation elements need to be stored for them either. For more information, 
	see <i>Section 7, <a href="#Weight_Derivation">Weight Derivation</a></i>.</p>
	<p>This means that only a small fraction of the total number of Unicode characters 
	need to have an explicit collation element. This can cut down the memory storage 
	considerably.</p>
	
	<h4>6.3.4 <a name="Reducing_the_Repertoire">Reducing the Repertoire</a></h4>
	
	<p>If characters are not fully supported by an implementation, then their code 
	points can be treated as if they were unassigned. This allows them to be algorithmically 
	constructed from code point values instead of including them in a table. This 
	can significantly reduce the size of the required tables. See <i>
	Section 7.1, <a href="#Derived_Collation_Elements">Derived Collation Elements</a></i> 
	for more information.</p>
	
	<h4>6.3.5 <a name="Memory_Table_Size">Memory Table Size</a></h4>
	
	<p>Applying the above techniques, an implementation can thus safely pack all 
	of the data for a collation element into a single 32-bit quantity: 16 for the 
	primary, 8 for the secondary and 8 for the tertiary. Then applying techniques 
	such as the Two-Stage table approach described in <i>&quot;Multistage Tables&quot;</i> 
	in <i>Section 5.1, Transcoding to Other Standards</i> of [<a href="#Unicode">Unicode</a>], 
	the mapping table from characters to collation elements can both fast and small. 
	For an example of how this can be done, see <i>
	Section 6.10, <a href="#Flat_File_Example">Flat File Example</a></i>.</p>
	
	<h3><a name="Avoiding_Zero_Bytes"></a>6.4 Avoiding Zero Bytes</h3>
	
	<p>If the resulting sort key is to be a C-string, then zero bytes must be avoided. 
	This can be done by:</p>
	<ul>
		<li>using the value 0101<sub>16</sub> for the level separator instead of 
		0000. </li>
		<li>preprocessing the weight values to avoid zero bytes, such as remapping 
		as follows:
		<ul>
			<li>x =&gt; 0101<sub>16</sub> + (x / 255)*256 + (x % 255) </li>
		</ul>
		</li>
		<li>Where the values are limited to 8-bit quantities (as discussed above), 
		zero bytes are even more easily avoided by just using 01 as the level separator 
		(where one is necessary), and mapping weights by
		<ul>
			<li>x =&gt; 01 + x. </li>
		</ul>
		</li>
	</ul>
	<h3><a name="Avoiding_Normalization"></a>6.5 Avoiding Normalization</h3>
	<p><a name="noCombining"></a>Implementations that do not handle separate combining 
	marks can map decomposable characters (such as &quot;à&quot;) to single collation elements 
	with different Level 2 weights for the different accents. For more information, 
	see <i>Section 7, <a href="#Weight_Derivation">Weight Derivation</a></i>. However, 
	this does require including the mappings for these characters in the collation 
	table, which will increase the size substantially unless the collation elements 
	for the Hangul Syllables are computed algorithmically.</p>
	
	<h3><a name="Case_Comparisons"></a>6.6 Case Comparisons</h3>
	
	<p>In some languages, it is common to sort lowercase before uppercase; in other 
	languages this is reversed. Often this is more dependent on the individual concerned, 
	and is not standard across a single language. It is strongly recommended that 
	implementations provide parameterization that allow uppercase to be sorted before 
	lowercase, and provide information as to the standard (if any) for particular 
	countries. This can easily be done to the Default Unicode Collation Element 
	Table before tailoring by remapping the L3 weights (see <i>
	Section 7, <a href="#Weight_Derivation">Weight Derivation</a></i>). It can be 
	done after tailoring by finding the case pairs and swapping the collation elements.</p>
	
	<h3><a name="Incremental_Comparison"></a>6.7 Incremental Comparison</h3>
	
	<p>Implementations do not actually have to produce full sort keys. Collation 
	elements can be incrementally generated as needed from two strings, and compared 
	with an algorithm that produces the same results as sort keys would have. The 
	choice of which algorithm to use depends on the number of comparisons between 
	the same strings.</p>
	<ul>
		<li>Generally incremental comparison is <i>more</i> efficient than producing 
		full sort keys if strings are only to be compared once and if they are generally 
		dissimilar, because differences are caught in the first few characters without 
		having to process the entire string. </li>
		<li>Generally incremental comparison is <i>less</i> efficient than producing 
		full sort keys if items are to be compared multiple times. </li>
	</ul>
	<p>However, it is very tricky to produce an incremental comparison that produces 
	correct results. For example, some implementations have not even been transitive! 
	Be sure to test any code for incremental comparison thoroughly.</p>
	<h3><a name="Catching_Mismatches"></a>6.8 Catching Mismatches</h3>
	<p>Sort keys from two different tailored collations cannot be compared, because 
	the weights may end up being rearranged arbitrarily. To catch this case, implementations 
	can produce a hash value from the collation data, and prepend it to the sort 
	key. Except in extremely rare circumstances, this will distinguish the sort 
	keys. The implementation then has the opportunity to signal an error.</p>
	<h3><a name="Comparison_to_Java"></a>6.9 Tailoring Example: Java</h3>
	<p>Java 2 implements a number of the tailoring features described in this document. 
	The following summarizes these features (for more information, see Collator 
	on [<a href="#JavaCollator">JavaCollator</a>]).</p>
	<p>1. Java does not use a default table in the Unicode Collation Element format: 
	instead it always uses a tailoring syntax. Here is a description of the entries:
	</p>
	<table class="syntax">
		<tr>
			<th>Java Syntax</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>&nbsp;&amp; y &lt; x</td>
			<td>Make x primary-greater than y</td>
		</tr>
		<tr>
			<td>&nbsp;&amp; y ; x</td>
			<td>Make x secondary-greater than y</td>
		</tr>
		<tr>
			<td>&nbsp;&amp; y , x</td>
			<td>Make x tertiary-greater than y</td>
		</tr>
		<tr>
			<td>&nbsp;&amp; y = x</td>
			<td>Make x equal to y</td>
		</tr>
	</table>
	<p>Either x or y can be more than one character, to handle contractions and 
	expansions. NULL is completely ignorable, so by using the above operations, 
	various levels of ignorable characters can be specified. </p>
	<p>2. Entries can be abbreviated in a number of ways: </p>
	<ul>
		<li>They do not need to be separated by newlines.</li>
		<li>Characters can be specified directly, instead of using their hexadecimal 
		Unicode values.</li>
		<li>Wherever you have rules of the form &quot;x &lt; y &amp; y &lt; z&quot;, you can omit &quot;&amp; 
		y&quot;, leaving just &quot;x &lt; y &lt; z&quot;.</li>
	</ul>
	<p>These can be done successively, so the following are equivalent in ordering.</p>
	<table class="example">
		<tr>
			<th align="LEFT">
			<p align="LEFT">Java</p>
			</th>
			<th align="LEFT">
			<p align="LEFT">Unicode Collation Element Table</p>
			</th>
		</tr>
		<tr>
			<td>&nbsp;a, A ; à, À &lt; b, B</td>
			<td>
			<pre>0061 ; [.0001.0001.0001] % a
0040 ; [.0001.0001.0002] % A
00E0 ; [.0001.0002.0001] % à
00C0 ; [.0001.0002.0002] % à
0042 ; [.0002.0001.0001] % b
0062 ; [.0002.0001.0002] % B</pre>
			</td>
		</tr>
	</table>
	<p>For a discussion of more powerful tailoring features, see [<a href="#ICUCollator">ICUCollator</a>]. 
	For details on a common XML format for tailorings, see [<a href="#LDML">LDML</a>].
	</p>
	<h3>6.10 <a name="Flat_File_Example">Flat File Example</a></h3>
	<p>The following is a sample flat-file binary layout and sample code for collation 
	data. It is included only for illustration. The table is used to generate collation 
	elements from characters, either going forwards or backwards, and detect the 
	start of a contraction. The backwards generation is for searching backwards 
	or Boyer-Moore-style searching; the contraction detection is for random access.</p>
	<p>In the file representation, ints are 32 bit values, shorts are 16, bytes 
	are 8 bits. Negatives are two&#39;s-complement. For alignment, the ends of all arrays 
	are padded out to multiples of 32 bits. The signature determines endianness. 
	The locale uses an ASCII representation for the Java locale: a 2 byte ISO language 
	code, optionally followed by &#39;_&#39; and 2 byte ISO country code, followed optionally 
	by a series of variant tags separated by &#39;_&#39;; any unused bytes are zero.</p>
	<table>
		<tr>
			<th><font size="2">Data</font></th>
			<th colspan="2"><font size="2">Comment</font></th>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int signature;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Constant <code>0x636F6C74</code>, 
			used also for big-endian detection</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int tableVersion;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Version of the table 
			format</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int dataVersion;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Version of the table 
			data</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">byte[32] locale;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Target locale (if any)</font></td>
		</tr>
		<tr>
			<td><font size="2">int flags;</font></td>
			<td colspan="2"><font size="2">Bit01 = 1 if French secondary<br>
			Others are reserved</font></td>
		</tr>
		<tr>
			<td><font size="2">int limitVariable;</font></td>
			<td colspan="2"><font size="2">Every ce below this value that has a 
			non-zero primary is variable. Because variables are not interleaved, 
			this does not need to be stored on a per-character basis.</font></td>
		</tr>
		<tr>
			<td><font size="2">int maxCharsPerCE;</font></td>
			<td colspan="2"><font size="2">Maximum number of characters that are 
			part of a contraction</font></td>
		</tr>
		<tr>
			<td><font size="2">int maxCEsPerChar;</font></td>
			<td colspan="2"><font size="2">Maximum number of collation elements 
			that are generated by an expansion</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int indexOffset;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to index table</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int collationElementsOffset;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to main data 
			table</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int expansionsOffset;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to expansion 
			table</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int contractionMatchOffset;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to contraction 
			match table</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int contractionResultOffset;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to contraction 
			values table</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int nonInitialsOffset;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Offset to non-initials 
			table. These are used for random access.</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int[10] reserved;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Reserved</font></td>
		</tr>
		<tr>
			<td><font size="2">int indexLength;</font></td>
			<td colspan="2"><font size="2">Length of following table</font></td>
		</tr>
		<tr>
			<td><font size="2">int[] index;</font></td>
			<td colspan="2"><font size="2">Index for high-byte (trie) table. Contains 
			offsets into Collation Elements. Data is accessed by:<br>
			<code>ce = collationElements[index[char&gt;&gt;8]+char&amp;0xFF]</code></font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int collationElementsLength;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Length of following 
			table</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int[] collationElements;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Each element is either 
			a real collation element, an expansionsOffset, or an contractionsOffset. 
			See below for more information.</font></td>
		</tr>
		<tr>
			<td><font size="2">int expansionsLength;</font></td>
			<td colspan="2"><font size="2">Length of following table</font></td>
		</tr>
		<tr>
			<td><font size="2">int[] expansions;</font></td>
			<td colspan="2"><font size="2">The expansionOffsets in the collationElements 
			table point into sublists in this table. Each list is terminated by 
			FFFFFFFF.</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int contractionMatchesLength;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Length of following 
			table</font></td>
		</tr>
		<tr>
			<td rowspan="4" bgcolor="#FFFFCC"><font size="2">short[] contractionMatches;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">The contractionOffsets 
			in the collationElements table point into sublists in this table. Each 
			sublist is of the following format:</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">short backwardsOffset;</font></td>
			<td bgcolor="#FFFFCC"><font size="2">When processing backwards, offset 
			to true contractions table.</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">short length;</font></td>
			<td bgcolor="#FFFFCC"><font size="2">Number of chars in list to search</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">short[] charsToMatch;</font></td>
			<td bgcolor="#FFFFCC"><font size="2">characters in sorted order.</font></td>
		</tr>
		<tr>
			<td><font size="2">int contractionCEsLength;</font></td>
			<td colspan="2"><font size="2">Length of following table</font></td>
		</tr>
		<tr>
			<td><font size="2">int[] contractionCEs;</font></td>
			<td colspan="2"><font size="2">List of CEs. Each corresponds to a position 
			in the contractionChars table. The one corresponding to the length in 
			a sublist is the <i>bail-out;</i> what to do if a match is not found.</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">int nonInitialsLength;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">Length of following 
			table</font></td>
		</tr>
		<tr>
			<td bgcolor="#FFFFCC"><font size="2">short[] nonInitials;</font></td>
			<td colspan="2" bgcolor="#FFFFCC"><font size="2">List of characters 
			(in sorted order) that can be non-initials in contractions. That is, 
			if &quot;ch&quot; is a contraction, then &quot;h&quot; is in this list. If &quot;abcd&quot; is a contraction, 
			then &quot;b&quot;, &quot;c&quot;, and &quot;d&quot; are in the list.</font></td>
		</tr>
	</table>
	<p><br>
	</p>
	<h4>6.10.1 <a name="Collation_Element_Format">Collation Element Format</a></h4>
	<ul>
		<li>&#39;real&#39; collationElement
		<ul>
			<li>16 bits primary (FFE0..FFFF not allowed)</li>
			<li>10 bits secondary</li>
			<li>&nbsp;6 bits tertiary</li>
		</ul>
		</li>
		<li>expansionsOffset
		<ul>
			<li>12 bits = FFF</li>
			<li>20 bits = offset (allows for 1,048,576 items)</li>
		</ul>
		</li>
		<li>contractionsOffset
		<ul>
			<li>12 bits = FFE</li>
			<li>20 bits = offset (allows for 1,048,576 items)</li>
		</ul>
		</li>
	</ul>
	<p>An alternative structure would have the offsets be byte offsets from the 
	start of the table, instead of indexes into the arrays. That would limit the 
	size of the table, but use fewer machine instructions.</p>
	
	<h4>6.10.2 <a name="Sample_Code">Sample Code</a></h4>
	
	<p>The following is a pseudo code using this table for the required operations. 
	Although using Java syntax in general, the code example uses arrays so as to 
	be more familiar to users of C and C++. <i>The code is presented for illustration 
	only; it is not a complete statement of the algorithm. </i></p>
	<pre>char[] input;   <span class="codeComment">// input buffer (i)</span>
int inputPos;   <span class="codeComment">// position in input buffer (io)</span>
int[] output;   <span class="codeComment">// output buffer (o)</span>
int outputPos;  <span class="codeComment">// position in output buffer (io)</span>
boolean forwards;   <span class="codeComment">// 0 for forwards, 1 for backwards (i)</span>
    
<span class="codeComment">/**
* Reads characters from input, writes collation elements in output
*/
</span>void getCollationElements() {
    char c = input[inputPos++];
    int ce = collationElements[index[c&gt;&gt;8] + c&amp;0xFF];
    processCE(ce);
}
    
<span class="codeComment">/**
* Normally just returns ce. However, special forms indicate that
* the ce is actually an expansion, or that we have to search
* to see if the character was part of a contraction.
* Expansions use 
*/
</span>void processCE(int ce) {
    if (ce &lt; 0xFFF00000) {
        output[outputPos++] = ce;
    } else if (ce &gt;= 0xFFE00000) {
        copyExpansions(ce &amp; 0x7FFFFF);
    } else {
        searchContractions(ce &amp; 0x7FFFFF);
    }
}
    
<span class="codeComment">/**
* Search through a contraction sublist to see if there is a match.
* Because the list is sorted, we can exit if our value is too high.&lt;p&gt;
* Because we have a length, we could implement this as a
* binary search, although we do not right now.&lt;p&gt;
* If we do find a match, we need to recurse. That&#39;s how &quot;abc&quot; would
* be handled.&lt;p&gt;
* If we fail, we return the non-matching case. That can be an expansion
* itself (it would never be a contraction).
*/
</span>void searchContractions(int offset) {
    if (forwards) inputPos++;
    else offset += input[inputPos++];
    short goal = (short)input[inputPos++];
    int limit = offset + contractionMatches[offset];
    for (int i = offset; i &lt; limit; ++i) {
        short cc = contractionMatches[i];
        if (cc &gt; goal) { <span class="codeComment">// definitely failed</span>
            processCE(contractionCEs[offset]);
            break;
        } else if (cc == goal) { <span class="codeComment">// found match</span>
            processCE(contractionCEs[i]);
            break;
        }
    }
}
    
<span class="codeComment">/**
* Copy the expansion collation elements up to the terminator.
* Do not use 00000000 as a terminator, because that may be a valid CE.
* These elements do not recurse.
*/
</span>void copyExpansions (int offset) {
    int ce = expansions[offset++];
    while (ce != 0xFFFFFFFF) {
        output[outputPos++] = ce;
        ce = expansions[offset++];
    }
}
    
<span class="codeComment">/**
* For random access, gets the start of a collation element.
* Any non-initial characters are in a sorted list, so
* we just check that list.&lt;p&gt;
* Because we have a length, we could implement this as a
* binary search, although we do not right now.
*/
</span>int getCollationElementStart(char[] buffer, int offset) {
    int i;
    main:
    for (i = offset; i &gt; 0; --i) {
        char c = buffer[i];
        for (int j = 0; j &lt; nonInitialsLength; ++j) {
            char n = nonInitials[j];
            if (c == n) continue main;
            if (c &gt; n) break main;
        }
        break;
    }
    return i;
}</pre>
	<h2><a name="Weight_Derivation"></a>7 Weight Derivation</h2>
	<p>This section describes the generation of the Unicode Default Unicode Collation 
	Element Table, and the assignment of weights to code points that are not explicitly 
	mentioned in a Collation Element Table. This uses information from the Unicode 
	Character Database [<a href="#UAX44">UAX44</a>].</p>
	<h3>7.1 <a name="Derived_Collation_Elements">Derived Collation Elements</a></h3>
	<p>CJK Ideographs and Hangul Syllables are not explicitly mentioned in the default 
	table. CJK ideographs are mapped to collation elements that are derived from 
	their Unicode code point value as described in <i>
	Section 7.1.3, <a href="#Implicit_Weights">Implicit Weights</a></i>.</p>
	<p>The collation algorithm requires that Hangul Syllables be decomposed. However, 
	if the table is tailored so that the primary weights for Hangul Jamo (and all 
	related characters) are adjusted, then the Hangul Syllables can be left as single 
	code points and treated in the same way as CJK ideographs. That will provide 
	a collation which is approximately the same as UCA, and may be sufficient in 
	environments where individual jamo are not expected.</p>
	<p>The adjustment is to move each initial jamo (and related characters) to have 
	a primary weight corresponding to the first syllables starting with that jamo, 
	and make all non-initial jamo (and related characters) be ignorable at a primary 
	level.</p>
	<h4><a name="Illegal_Code_Points">7.1.1 Illegal Code Points</a></h4>
	<p>Certain code points are illegal in a data stream. These include noncharacters 
	(code points with the Noncharacter_Code_Point property in the Unicode Character 
	Database [<a href="#UAX44">UAX44</a>]), unpaired surrogates (code points with the 
	General_Category property Cs), and out-of-range values (&lt; 0 or &gt; 10FFFF). Implementations 
	may also choose to treat these as error conditions and respond appropriately, 
	such as by throwing an exception.</p>
	<p>If they are not treated as an error condition, they must be mapped to [.0000.0000.0000.], 
	and thus ignored.</p>
	<h4><a name="Legal_Code_Points">7.1.2 Legal Code Points</a></h4>
	<p>Any other legal code point that is not explicitly mentioned in the table 
	is mapped a sequence of two collation elements as described in <i>
	Section 7.1.3, <a href="#Implicit_Weights">Implicit Weights</a></i>.</p>
	
	<h4>7.1.3 <a name="Implicit_Weights">Implicit Weights</a></h4>
	
	<p>A character is mapped to an implicit weight in the following way. The result 
	of this process consists of collation elements that are sorted in code point 
	order, that do not collide with any explicit values in the table, and that can 
	be placed anywhere (for example, at BASE) with respect to the explicit collation 
	element mappings (by default, they go after all explicit collation elements).</p>
	
	<p>To derive the collation elements, the value of the code point is used to calculate two numbers, by bit shifting and bit masking. The bit operations are chosen so that the resultant numbers have the desired ranges for constructing implicit weights. The first number is calculated by taking the code point expressed as a 32-bit binary integer CP and bit shifting it right by 15 bits. Because code points range from U+0000 to U+10FFFF, the result will be a number in the range 0 to 21<sub>16</sub> (= 33<sub>10</sub>). This number is then added to the special value BASE.</p>
    <blockquote>
      <p>AAAA = BASE + (CP &gt;&gt; 15);</p>
    </blockquote>
	<p>Now mask off the bottom 15 bits of CP. OR a 1 into bit 15, so that the resultant value is non-zero.</p>
    <blockquote>
      <p>BBBB = (CP &amp; 0x7FFF) | 0x8000;</p>
    </blockquote>
	<p>AAAA and BBBB are interpreted as unsigned 16-bit integers. The implicit weight mapping given to the code point is then constructed as:</p>
	<blockquote>
	  <p>[.AAAA.0020.0002.][.BBBB.0000.0000.]</p>
  </blockquote>
<p>If a fourth or higher weights are used, then the same pattern is used: they 
	are set to a non-zero value, and so on in the first collation element and zero 
	in the second. (Because all distinct code points have different <b>AAAA/BBBB</b> 
	combination, the exact non-zero value does not matter.)</p>
  <p>The value for BASE depends on the type of character. The first BASE value is for the core Han Unified Ideographs. The second BASE value is for all other Unified Han ideographs. In both of these cases, compatibility decomposibles are excluded, since they are otherwise handled in the UCA. Unassigned codepoints are also excluded from these first two BASE values. The final BASE value is for all other code points, including unassigned code points.</p>
	<table cellpadding="4">
	  <tr>
			<td class="syntax">FB40</td>
			<td class="syntax"><p>Unified_Ideograph=True <strong>AND</strong><br>
		    ((Block=CJK_Unified_Ideograph) OR (Block=CJK_Compatibility_Ideographs))</p>
			  <p>In regex notation: 			    <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\p{Block%3DCJK_Unified_Ideographs}\p{Block%3DCJK_Compatibility_Ideographs}-\P{unified_ideograph}]">[\p{unified_ideograph}&amp;[\p{Block=CJK_Unified_Ideographs}\p{Block=CJK_Compatibility_Ideographs}]]</a><br>
	      </p></td>
		</tr>
		<tr>
			<td class="syntax">FB80</td>
			<td class="syntax"><p>Unified_Ideograph=True <strong>AND NOT</strong><br>
		    ((Block=CJK_Unified_Ideograph) OR (Block=CJK_Compatibility_Ideographs))</p>
		    <p>In regex notation:
			<a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\p{unified+ideograph}-\p{Block%3DCJK_Unified_Ideographs}-\p{Block%3DCJK_Compatibility_Ideographs}]">[\p{unified ideograph}-[\p{Block=</a><a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[\p{unified+ideograph}-\p{Block%3DCJK_Unified_Ideographs}-\p{Block%3DCJK_Compatibility_Ideographs}]">CJK_Unified_Ideographs}\p{Block=CJK_Compatibility_Ideographs}]]</a></p></td>
		</tr>
		<tr>
			<td class="syntax">FBC0</td>
			<td class="syntax">Any other code point</td>
		</tr>
	</table>
	<p>These results make AAAA (in each case) larger than any explicit primary weight; 
	thus the implicit weights will not collide with explicit weights. It is not 
	generally necessary to tailor these values to be within the range of explicit 
	weights. However if this is done, the explicit primary weights must be shifted 
	so that none are between each of the BASE values and BASE + 34.</p>
	<h4>7.1.4 <a name="Trailing_Weights">Trailing Weights</a></h4>
	<p>The range of primary weights from FC00 to FFFF is available for use as trailing 
	weights especially for the case of Hangul Syllables. These syllables can be 
	of the form LL*VV*T*: that is, one or more Lead jamo, followed by one or more 
	Vowel jamo, followed optional by any number of Trail jamos. For more information, 
	see <i>Section 3.12, Conjoining Jamo Behavior</i> in [<a href="#Unicode">Unicode</a>].</p>
	<p>Trailing weights are for characters that are given primary weights, but grouped 
	as a unit together with a previous character, such as U+1160 HANGUL JUNGSEONG 
	FILLER through U+11F9 HANGUL JONGSEONG YEORINHIEUH. By tailoring these 
	characters in this range, the units are ordered independently of subsequent 
	characters with higher weights. Otherwise problems may occur, such as in the 
	following example.</p>
	<div align="center">
		<center>
		<table class="noborder" cellpadding="4">
			<tr>
				<th width="50%" align="center" class="noborder"><b>Case 1</b></th>
				<th width="50%" align="center" class="noborder"><b>Case 2</b></th>
			</tr>
			<tr>
				<td width="50%" class="noborder">
				<div align="center">
					<center>
					<table cellspacing="0" cellpadding="4" border="1" class="example">
						<tr>
							<th><font size="3">1</font></th>
							<td><font size="3">{G}{A}</font></td>
						</tr>
						<tr>
							<th><font size="3">2</font></th>
							<td><font size="3">{G}{A}{K}</font></td>
						</tr>
					</table>
					</center></div>
				</td>
				<td width="50%" class="noborder">
				<div align="center">
					<center>
					<table cellspacing="0" cellpadding="4" border="1" class="example">
						<tr>
							<th><font size="3">2</font></th>
							<td><font size="3">{G}{A}{K}囗</font></td>
						</tr>
						<tr>
							<th><font size="3">1</font></th>
							<td><font size="3">{G}{A}囗</font></td>
						</tr>
					</table>
					</center></div>
				</td>
			</tr>
		</table>
		</center></div>
	<p>In this example, the symbols {G}, {A}, and {K} represent letters in a script 
	where syllables (or other sequences of characters) are sorted as units. By proper 
	choice of weights for the individual letters, the syllables can be ordered correctly. 
	But the weights of the following letters may cause syllables of different lengths 
	to change order. Thus <font size="3">{G}{A}{K}</font> comes after GA in Case 
	1. But in Case 2, it comes <i>before</i>. That is, the order of these two syllables 
	would be reversed when each is followed by a CJK character: in this case, U+56D7 
	(<font size="3">囗)</font>.</p>
	<h5>7.1.4.1 <a name="Hangul_Trailing_Weights">Hangul Trailing Weights</a></h5>
	<p>Hangul is in a rather unique position, because of the large number of the 
	precomposed characters, and because those precomposed characters are the normal 
	(NFC) form of interchanged text. For Hangul syllables to sort correctly, either 
	the UCA data must be tailored or the UCA algorithm (and data) must be tailored. 
	The following are possible solutions:</p>
	<p><b>Data Method</b></p>
	<ol>
		<li>Tailor the Vs and Ts to be Trailing Weights, with the ordering T &lt; V</li>
		<li>Tailor each sequence of multiple L&#39;s that occurs in the repertoire as 
		a contraction, with an independent primary weight after any prefix&#39;s weight<ul>
			<li>This means that if L<sub>1</sub> has a primary weight of 555, and 
			L<sub>2</sub> has 559, then L<sub>1</sub>L<sub>2</sub> would have to 
			be given a weight from 556 to 558.</li>
		</ul>
		</li>
	</ol>
	<p><b>Terminator Method</b></p>
	<ol>
		<li>Add an internal terminator primary weight (<font face="Arial Unicode MS">Ⓣ</font>).</li>
		<li>Tailor all Jamo so that <font face="Arial Unicode MS">Ⓣ</font> &lt; T &lt; 
		V &lt; L</li>
		<li>Algorithmically add the terminator primary weight (<font face="Arial Unicode MS">Ⓣ</font>) 
		to the end of every standard Hangul syllable.<ul>
			<li>This is done by adding the terminator between any pairs of characters 
			that are not kept together according to the rules of <i>Section 3.12,
			Conjoining Jamo Behavior</i> of [<a href="#Unicode">Unicode</a>]</li>
		</ul>
		</li>
	</ol>
	<p><b>Interleaving Method</b></p>
	<ol>
		<li>Generate a modified weight table:<ol type="a">
			<li>Assign a weight to each precomposed Hangul Syllable character, with 
			a 1-weight gap between each one. (see <i>
			Section 6.2, <a href="#Large_Weight_Values">Large Weight Values</a></i>)</li>
			<li>Give each Jamo a 1-byte internal weight. Also add an internal terminator 
			1-byte weight (<font face="Arial Unicode MS">Ⓣ</font>). These are assigned 
			so that all <font face="Arial Unicode MS">Ⓣ</font> &lt; T &lt;&nbsp; V &lt; L.<ul>
				<li>These weights are separate from the default weights, and are 
				just used internally.</li>
			</ul>
			</li>
		</ol>
		</li>
		<li>When any string of Jamo and/or Hangul Syllables is encountered, break 
		it into syllables according to the rules of <i>Section 3.12, Conjoining Jamo 
		Behavior</i> of [<a href="#Unicode">Unicode</a>]. Process each syllable 
		separately:<ol type="a">
			<li>If a syllable is canonically equivalent to one of the precomposed 
			Hangul Syllables, then just assign the weight as above</li>
			<li>If not, then find the greatest syllable that it is greater than; 
			call that the base syllable. Generate a weight sequence corresponding 
			to the following gap weight, followed by all the Jamo weight bytes, 
			followed by the terminator byte.</li>
		</ol>
		</li>
	</ol>
	<p>Each of these methods can correctly represent the ordering of all modern 
	and ancient Hangul Syllables, but there are implementation trade-offs between 
	them. These trade-offs can have a significant impact on the acceptability of 
	the implementation, because substantially longer sort keys will cause significant 
	performance degradations and database index bloat.</p>
	<blockquote>
		<p><b>Note:</b> If the repertoire of supported Hangul syllables is limited 
		to modern syllables (those of the form LV or LVT), then all of these become 
		simpler.</p>
	</blockquote>
	<p>The Data method provides for the following order of weights, where the X<sub>b</sub> 
	are all the scripts sorted before Hangul, and the X<sub>a</sub> are all those 
	sorted after. </p>
	<blockquote>
		<table border="1" style="border-collapse: collapse" cellpadding="2" cellspacing="0">
			<tr>
				<td align="center" width="144" style="text-align: center">X<sub>b</sub></td>
				<td align="center" style="text-align: center">L</td>
				<td align="center" width="144" style="text-align: center">X<sub>a</sub></td>
				<td align="center" style="text-align: center">T</td>
				<td align="center" style="text-align: center">V</td>
			</tr>
		</table>
		<p>This ordering gives the right results among the following:</p>
		<table border="1" cellpadding="2" cellspacing="0">
			<tr>
				<th align="left">Chars</th>
				<th align="left" colspan="4">Weights</th>
				<th align="left">Comments</th>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>a</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>Xa</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">L</font>...</th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#FF0000">W</font><sub><font color="#ff0000">Ln</font></sub></th>
				<th align="left">...</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>b</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#ff0000">W<sub>Xb</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">T<sub>1</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>T1</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>T</sub> &gt; all W<sub>X</sub> and W<sub>L</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">V<sub>1</sub></font><font color="#ff0000">V<sub>2</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left"><font color="#008000">W<sub>V1</sub></font></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>V2</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>V</sub> &gt; all W<sub>T</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">L<sub>2</sub></font>V<sub>1</sub></th>
				<th align="left">W<sub>L1</sub><font color="#008000"><sub>L2</sub></font></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left">&nbsp;</th>
				<th align="left">&nbsp;</th>
				<td>Works <b><i>if</i></b> L<sub>1</sub>L<sub>2</sub> is a contraction.</td>
			</tr>
		</table>
	</blockquote>
	<p>The disadvantages of the Data method are that the weights for T and V are 
	separated from those of L, which can cause problems for sort-key compression, 
	and that a combination of LL that is outside the contraction table will not 
	sort properly. </p>
	<p>The Terminator method would assign the following weights:</p>
	<blockquote>
		<table border="1" style="border-collapse: collapse" cellpadding="2" cellspacing="0">
			<tr>
				<td align="center" style="text-align: center">
				<font face="Arial Unicode MS">Ⓣ</font></td>
				<td align="center" width="144" style="text-align: center">X<sub>b</sub></td>
				<td align="center" style="text-align: center">T</td>
				<td align="center" style="text-align: center">V</td>
				<td align="center" style="text-align: center">L</td>
				<td align="center" width="144" style="text-align: center">X<sub>a</sub></td>
			</tr>
		</table>
		<p>This ordering gives the right results among the following:</p>
		<table border="1" cellpadding="2" cellspacing="0">
			<tr>
				<th align="left">Chars</th>
				<th align="left" colspan="5">Weights</th>
				<th align="left">Comments</th>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>a</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>Xa</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">L<sub>n</sub></font>...</th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left"><font color="#FF0000">W</font><sub><font color="#ff0000">Ln</font></sub></th>
				<th align="left">...</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>b</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left"><font color="#ff0000">W<sub>Xb</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">T<sub>1</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>T1</sub></font></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>T</sub> &gt; all W<sub>X</sub> and
				<font face="Arial Unicode MS">Ⓣ</font></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">V<sub>1</sub></font><font color="#ff0000">V<sub>2</sub></font></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left"><font color="#008000">W<sub>V1</sub></font></th>
				<th align="left"><font color="#FF0000">W</font><font color="#ff0000"><sub>V2</sub></font></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>V</sub> &gt; all W<sub>T</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">L<sub>2</sub></font>V<sub>1</sub></th>
				<th align="left">W<sub>L1</sub></th>
				<th align="left"><font color="#008000">W<sub>L2</sub></font></th>
				<th align="left">W<sub>V1</sub></th>
				<th align="left"><font face="Arial Unicode MS">Ⓣ</font></th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>L</sub> &gt; all W<sub>V</sub></td>
			</tr>
		</table>
	</blockquote>
	<p>The disadvantages of the Terminator method are that an extra weight is added 
	to all Hangul syllables, increasing the length of sort keys by roughly 40%, 
	and the fact that the terminator weight is non-contiguous can disable sort-key 
	compression.</p>
	<p>The Interleaving method provides for the following assignment of weights. 
	W<sub>n</sub> represents the weight of a Hangul Syllable, and W<sub>n&#39;</sub> 
	is the weight of the gap right after it. The L, V, T weights will only occur 
	after a W, and thus can be considered part of an entire weight.</p>
	<blockquote>
		<table border="1" style="border-collapse: collapse" cellpadding="2" cellspacing="0">
			<tr>
				<td align="center" width="144" style="text-align: center">X<sub>b</sub></td>
				<td align="center" style="text-align: center">W</td>
				<td align="center" width="144" style="text-align: center">X<sub>a</sub></td>
			</tr>
		</table>
		<p><font face="Arial Unicode MS">byte weights: </font></p>
		<table border="1" style="border-collapse: collapse" cellpadding="2" cellspacing="0">
			<tr>
				<td align="center" style="text-align: center">
				<font face="Arial Unicode MS">Ⓣ</font></td>
				<td align="center" style="text-align: center">T</td>
				<td align="center" style="text-align: center">V</td>
				<td align="center" style="text-align: center">L</td>
			</tr>
		</table>
		<p>This ordering gives the right results among the following:</p>
		<table border="1" cellpadding="2" cellspacing="0">
			<tr>
				<th align="left">Chars</th>
				<th align="left" colspan="3">Weights</th>
				<th align="left">Comments</th>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>a</sub></font></th>
				<th align="left">W<sub>n</sub></th>
				<th align="left"><font color="#ff0000">X<sub>a</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">L<sub>n</sub></font>...</th>
				<th align="left">W<sub>n</sub></th>
				<th align="left"><font color="#FF0000">W<sub>k</sub></font></th>
				<th align="left">...</th>
				<td>The L<sub>n</sub> will start another syllable</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">X<sub>b</sub></font></th>
				<th align="left">W<sub>n</sub></th>
				<th align="left"><font color="#ff0000">X<sub>b</sub></font></th>
				<th align="left">&nbsp;</th>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub>V<sub>1</sub><font color="#ff0000">T<sub>1</sub></font></th>
				<th align="left">W<sub>m</sub></th>
				<th align="left">&nbsp;</th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>m</sub> &gt; W<sub>n</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">V<sub>1</sub></font><font color="#ff0000">V<sub>2</sub></font></th>
				<th align="left">W<sub>m&#39;L1</sub><font color="#008000"><sub>V1</sub></font><font color="#ff0000"><sub>V2</sub></font><sub><font face="Arial Unicode MS">Ⓣ</font></sub></th>
				<th align="left">&nbsp;</th>
				<th align="left">&nbsp;</th>
				<td>Works because W<sub>m&#39;</sub>&gt;W<sub>m</sub></td>
			</tr>
			<tr>
				<th align="left">L<sub>1</sub><font color="#008000">L<sub>2</sub></font>V<sub>1</sub></th>
				<th align="left">W<sub>m&#39;L1</sub><font color="#008000"><sub>L2</sub></font><sub>V1<font face="Arial Unicode MS">Ⓣ</font></sub></th>
				<th align="left">&nbsp;</th>
				<th align="left">&nbsp;</th>
				<td>Works because the byte weight for <font color="#008000">
				<sub>L2</sub></font> &gt; all <font color="#008000"><sub>V</sub></font></td>
			</tr>
		</table>
	</blockquote>
	<p>The Interleaving method is somewhat more complex than the others, but produces 
	the shortest sort keys for all of the precomposed Hangul Syllables, so for normal 
	text it will have the shortest sort keys. If there were a large percentage of 
	ancient Hangul Syllables, the sort keys would be longer than other methods.</p>
	<blockquote>
	<p><b>Note:</b> The Unicode Consortium recognizes that one of these solutions 
	should be implemented in the standard UCA algorithm and tables, but is attempting 
	to work out a common approach to the problem with the ISO SC2 OWG-SORT group, which 
	takes considerable time. In the meantime, one of these approaches can be used 
	for correct ordering.</p>
	</blockquote>
	
	<h3>7.2 <a name="Canonical_Decompositions">Canonical Decompositions</a></h3>
	
	<p>Characters with canonical decompositions do not require mappings to collation 
	elements, because Step 1.1 maps them to collation elements based upon their 
	decompositions. However, they may be given mappings to collation elements anyway. 
	The weights in those collation elements must be computed in such a way they 
	will sort in the same relative location as if the characters were decomposed 
	using Normalization Form D. By including these mappings, this allows an implementation 
	handling a restricted repertoire of supported characters to compare strings 
	correctly without performing the normalization in Step 1.1 of the algorithm.</p>
	<p>A combining character sequence is called <i>impeding</i> if it contains any 
	conjoining Jamo, or if it contains an L1-ignorable combining mark and there 
	is some character that canonically decomposes to a sequence containing the same 
	base character. For example, the sequence &lt;a, cedilla&gt; is an impediment, because
	<i>cedilla</i> is an L1-ignorable character, and there is some character (for 
	example, <i>a-grave</i>) that decomposes to a sequence containing the same base 
	letter <i>a</i>. Note that although strings in Normalization Form C generally 
	do not contain impeding sequences, there is nothing prohibiting them from containing 
	them.</p>
	<blockquote>
		<p><b>Note:</b> Conformant implementations that do not support impeding 
		character sequences as part of their repertoire can avoid performing Normalization 
		Form D processing as part of collation.</p>
	</blockquote>
	<h3>7.3 <a name="Compatibility_Decompositions">Compatibility Decompositions</a></h3>
	<p>As remarked above, most characters with compatibility decompositions can 
	have collation elements computed at runtime to save space, duplicating the work 
	that was done to compute the Default Unicode Collation Element Table. This can 
	be an important savings in memory space. The process works as follows.</p>
	<p><b>1. </b>Derive the compatibility decomposition. For example,</p>
	<blockquote>
		<pre>2475 PARENTHESIZED DIGIT TWO =&gt; 0028, 0032, 0029</pre>
	</blockquote>
	<p><b>2. </b>Look up the collation
	element for each character in the decomposition. For example,</p>
	<blockquote>
		<pre>0028 [*023D.0020.0002] % LEFT PARENTHESIS
0032 [.06C8.0020.0002] % DIGIT TWO
0029 [*023E.0020.0002] % RIGHT PARENTHESIS</pre>
	</blockquote>
	<p><b>3. </b>Set the first two L3 values to be lookup (L3), where the lookup function uses the table in <i>Section 7.3.1, <a href="#Tertiary_Weight_Table">Tertiary 
	Weight Table</a></i>. Set the remaining L3 values to MAX (which in the default 
	table is 001F). For example,</p>
	<blockquote>
		<pre>0028 [*023D.0020.0004] % LEFT PARENTHESIS
0032 [.06C8.0020.0004] % DIGIT TWO
0029 [*023E.0020.001F] % RIGHT PARENTHESIS</pre>
	</blockquote>
	<p><b>4.</b> Concatenate the result to produce the sequence of collation elements 
	that the character maps to. For example,</p>
	<blockquote>
		<pre>2475 [*023D.0020.0004] [.06C8.0020.0004] [*023E.0020.001F] </pre>
	</blockquote>
	<p>Some characters cannot be computed in this way. They must be filtered out 
	of the default table and given specific values. For example,</p>
	<blockquote>
		<pre>017F [.085D.00FD.0004.017F] % LATIN SMALL LETTER LONG S; COMPAT</pre>
	</blockquote>
	<h4>7.3.1 <a name="Tertiary_Weight_Table">Tertiary Weight Table</a></h4>
	<p>Characters are given tertiary weights according to the following table. The 
	Decomposition Type is from the Unicode Character Database [<a href="#UAX44">UAX44</a>]. 
	The Condition is either based on the General Category or on a specific list 
	of characters. The weights are from MIN = 2 to MAX = 1F<sub>16</sub>, excluding 
	7, which is not used for historical reasons. The Samples show some minimal values 
	that are distinguished by the different weights. All values are distinguished 
The samples have empty cells when there are no (visible) values showing a distinction.</p>
	<div align="center">
		<center>
		<table cellspacing="0" border="1" class="values" cellpadding="2">
			<tr>
				<th>Type</th>
				<th>Condition</th>
				<th>Weight</th>
				<th colspan="6">
				<p style="text-align: center">Samples</p>
				</th>
			</tr>
			<tr>
				<td><code>&nbsp;NONE</code></td>
				<td>&nbsp;</td>
				<td><code>0x0002</code></td>
				<td>i</td>
				<td>ب</td>
				<td>)</td>
				<td>mw</td>
				<td>1⁄2</td>
				<td><b><i>X</i></b></td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;wide&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0003</code></td>
				<td>ｉ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;compat&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0004</code></td>
				<td>ⅰ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;font&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0005</code></td>
				<td>ℹ </td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;circle&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0006</code></td>
				<td>ⓘ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td class="unused"><code>!unused!</code></td>
				<td class="unused">&nbsp;</td>
				<td class="unused"><code>0x0007</code></td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
				<td class="unused">&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;NONE</code></td>
				<td>Uppercase</td>
				<td><code>0x0008</code></td>
				<td>I</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>MW</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;wide&gt;</code></td>
				<td>Uppercase</td>
				<td><code>0x0009</code></td>
				<td>Ｉ</td>
				<td>&nbsp;</td>
				<td>）</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;compat&gt;</code></td>
				<td>Uppercase</td>
				<td><code>0x000A</code></td>
				<td>Ⅰ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;font&gt;</code></td>
				<td>Uppercase</td>
				<td><code>0x000B</code></td>
				<td>ℑ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;circle&gt;</code></td>
				<td>Uppercase</td>
				<td><code>0x000C</code></td>
				<td>Ⓘ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;small&gt;</code></td>
				<td>small hiragana (3041, 3043, ...)</td>
				<td><code>0x000D</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ぁ</td>
			</tr>
			<tr>
				<td><code>&nbsp;NONE</code></td>
				<td>normal hiragana (3042, 3044, ...)</td>
				<td><code>0x000E</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>あ</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;small&gt;</code></td>
				<td>small katakana (30A1, 30A3, ...)</td>
				<td><code>0x000F</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>﹚</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ァ</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;narrow&gt;</code></td>
				<td>small narrow katakana (FF67..FF6F)</td>
				<td><code>0x0010</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ｧ</td>
			</tr>
			<tr>
				<td><code>&nbsp;NONE</code></td>
				<td>normal katakana (30A2, 30A4, ...)</td>
				<td><code>0x0011</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ア</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;narrow&gt;</code></td>
				<td>narrow katakana (FF71..FF9D),<br>
				narrow hangul (FFA0..FFDF)</td>
				<td><code>0x0012</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>ｱ</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;circle&gt;</code></td>
				<td>circled katakana (32D0..32FE)</td>
				<td><code>0x0013</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>㋐</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;super&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0014</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>⁾</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;sub&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0015</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>₎</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;vertical&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0016</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>︶</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;initial&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0017</code></td>
				<td>&nbsp;</td>
				<td>ﺑ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;medial&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0018</code></td>
				<td>&nbsp;</td>
				<td>ﺒ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;final&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x0019</code></td>
				<td>&nbsp;</td>
				<td>ﺐ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;isolated&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x001A</code></td>
				<td>&nbsp;</td>
				<td>ﺏ</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;noBreak&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x001B</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;square&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x001C</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>㎽</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;square&gt;, &lt;super&gt;, &lt;sub&gt; </code></td>
				<td>Uppercase</td>
				<td><code>0x001D</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>㎿</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;&lt;fraction&gt;</code></td>
				<td>&nbsp;</td>
				<td><code>0x001E</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>½</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td><code>&nbsp;n/a</code></td>
				<td>&nbsp;(MAX value)</td>
				<td><code>0x001F</code></td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
		</table>
		</center></div>
	<p><br>
	</p>
	<h2><a name="Searching"></a>8 Searching and Matching</h2>
	<p>Language-sensitive searching and matching are closely related to collation. 
	Strings that compare as equal at some strength level are those that should be 
	matched when doing language-sensitive matching. For example, at a primary strength, 
	&quot;ß&quot; would match against &quot;ss&quot; according to the UCA, and &quot;aa&quot; would match &quot;å&quot; 
	in a Danish tailoring of the UCA. The main difference from the collation comparison 
	operation is that the ordering is not important. Thus for matching it doesn&#39;t 
	matter that &quot;å&quot; would sort after &quot;z&quot; in a Danish tailoring: the only relevant 
	information is that they don&#39;t match.</p>
	<p>The basic operation is matching: determining whether string X matches string 
	Y. Other operations are built on this:</p>
	<ul>
		<li>Y contains X when there is some substring of Y that matches X</li>
		<li>A search for a string X in a string Y succeeds if Y contains X.</li>
		<li>Y starts with X when some initial substring of Y matches X</li>
		<li>Y ends with X when some final substring of Y matches X</li>
	</ul>
	<p>The collation settings determine the results of the matching operation (see
	<i>Section 5.1, <a href="#Parametic_Tailoring">Parametric Tailoring</a></i>). 
	Thus users of searching and matching need to be able to modify parameters such 
	as locale or comparison strength. For example, setting the strength to exclude 
	differences at Level 3 has the effect of ignoring case and compatibility format 
	distinctions between letters when matching. Excluding differences at Level 2 
	has the effect of also ignoring accentual distinctions when matching.</p>
	<p>Conceptually, a string matches some target where a substring of the target 
	has the same sort key. But there are a number of complications:</p>
	<ol>
		<li>The lengths of matching strings may differ: &quot;aa&quot; and &quot;<font size="3">å&quot; 
		would match in Danish.</font></li>
		<li><font size="3">Because of ignorables (at different levels), </font>there 
		are different possible positions where a string matches, depending on the 
		attribute settings of the collation. For example, if hyphens are ignorable 
		for a certain collation, then &quot;abc&quot; will match &quot;abc&quot;, &quot;abc-&quot;, &quot;-abc-&quot;, and 
		so on.</li>
		<li>Suppose that the collator has contractions, and that a contraction spans 
		the boundary of the match. Whether or not it is considered a match may depend 
		on user settings, just as users are given a &quot;Whole Words&quot; option in searching. 
		So in a language where &quot;ch&quot; is a contraction, &quot;bac&quot; would not match in &quot;bach&quot; 
		(given the proper user setting).</li>
		<li>Similarly, combining character sequences may need to be taken into account. 
		Users may not want a search for &quot;abc&quot; to match in &quot;...ab<font size="3">ç...&quot; 
		(with a cedilla on the c). However, this may also depend on language and 
		user customization.</font></li>
		<li><font size="3">The above two conditions can be considered part of a 
		general condition: &quot;Whole Characters Only&quot;; very similar to the common &quot;Whole 
		Words Only&quot; checkbox that is included in most search dialog boxes.</font> 
		(For more information on grapheme clusters, see [<a href="#UTS18">UTS18</a>].</li>
		<li>If the matching does not check for <font size="3">&quot;Whole
		Characters Only&quot;</font>, 
		then some other complications may occur. For example, suppose that P is 
		&quot;x<font size="3">^&quot;, and Q is &quot;</font>x ^<font size="3">¸&quot;. Because the 
		cedilla and circumflex can be written in arbitrary order and still be equivalent, 
		one would expect to find a match for P in Q. A canonically-equivalent matching 
		process requires special processing at the boundaries to check for situations 
		like this. (It does not require such special processing within the P or 
		the substring of Q because collation is defined to observe canonical equivalence.)</font></li>
	</ol>
	<p>The following are used to provide a clear definition of searching and matching 
	that deal with the above complications:</p>
	<p><b>DS1. </b>Define <i>S[start,end]</i> to be the substring of S that includes 
	the character after the offset <i>start</i> up to the character before offset
	<i>end</i>. For example, if S is &quot;abcd&quot;, then S[1,3] is &quot;bc&quot;. Thus S = S[0,length(S)].</p>
	<p><b>DS1a. </b>A boundary condition is a test imposed on an offset within a 
	string. <font size="3">An example includes Whole Word Search, as defined in 
	UAX #29.</font></p>
	<p>The tailoring parameter <i>match-boundaries</i> specifies constraints on 
	matching (see <i>Section 5.1, <a href="#Parametic_Tailoring">Parametric Tailoring</a></i>). 
	The parameter <i>match-boundaries=whole-character</i> requires that the start 
	and end of a match each be on a grapheme boundary. The value <i>match-boundaries=whole-character</i> 
	further requires that the start and end of a match each be on a word boundary 
	as well. For more information on the specification of these boundaries, see 
	[<a href="#UAX29">UAX29</a>].</p>
	<p>By using grapheme-complete conditions, contractions and combining sequences 
	are not interrupted. This also avoids the need to present visually discontiguous 
	selections to the user (except for BIDI text).</p>
	<p>Suppose there is a collation C, a pattern string P and a target string Q, 
	and a boundary condition B. C has some particular set of attributes, such as 
	a strength setting, and choice of variable weighting.</p>
	<p><b>DS2.</b> The pattern string<b> </b>P <i>has a match at Q[s,e] according 
	to collation C</i> if C generates the same sort key for P as for Q[s,e], and 
	the offsets <i>s</i> and <i>e</i> meet the boundary condition B. We also say 
	P has a match in Q according to C.</p>
	<p><b>DS3. </b>The pattern string<b> </b>P has a <i>canonical</i> match at Q[s,e] 
	according to collation C if there is some Q&#39; that is canonically equivalent 
	to Q[<i>s,e</i>], and P has a match in Q&#39;.</p>
	<blockquote>
		<p>For example, suppose that P is &quot;Å&quot;, and Q is &quot;...A◌̥◌̊...&quot;. There would 
		not be a match for P in Q, but there would be a canonical match, because 
		P does have a match in &quot;A◌̊◌̥&quot;, which is canonically equivalent to &quot;A◌̥◌̊&quot;. 
		However, it is not commonly necessary to use canonical matches, so this 
		definition is only supplied for completeness.</p>
	</blockquote>
	<p>Each of the following are qualifications of DS2 or DS3.</p>
	<p><b>DS3a. </b>The match <font size="3">is</font> <i>grapheme-complete</i> 
	if B requires that the offset be at a grapheme cluster boundary. Note that Whole 
	Word Search as defined in [<a href="#UAX29">UAX29</a>] is grapheme complete.</p>
	<p><b>DS4. </b>The match is <i>minimal</i> if there is no match at Q[<i>s+i,e-j</i>] 
	for any <i>i</i> and <i>j such that i <font face="Times New Roman">≥</font> 
	0, j</i> <font face="Times New Roman">≥</font> 0, and <i>i</i> + <i>j</i> &gt; 
	0. In such a case, we also say that P has a <i>minimal</i> match <i>at</i> Q[<i>s,e</i>].</p>
	<p><b>DS4a. </b>The match is <i>medial</i> when it is contained in the maximal 
	match, contains the minimal match, and is extended beyond the minimal match 
	whenever there is a successive binary match between the extra characters in 
	pattern and target.</p>
	<p><b>DS4b. </b>The match is <i>maximal</i> if there is no match at Q[<i>s-i,e+j</i>] 
	for any <i>i</i> and <i>j such that i <font face="Times New Roman">≥</font> 
	0, j</i> <font face="Times New Roman">≥</font> 0, and <i>i</i> + <i>j</i> &gt; 
	0. In such a case, we also say that P has a <i>maximal</i> match <i>at</i> Q[<i>s,e</i>].</p>
	<p>As an example of the differences between these, consider the following case, 
	where the collation strength is set to ignore punctuation and case, and <u>format</u><b>
	</b>indicates the match.</p>
	<table border="1" cellpadding="2" cellspacing="0" style="border-collapse: collapse">
		<tr>
			<th style="text-align: right" nowrap>&nbsp;</th>
			<th nowrap>Text</th>
			<th>Description</th>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Pattern</th>
			<td nowrap>*!abc!*</td>
			<td>Notice that the *! and !* are ignored in matching.</td>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Target Text</th>
			<td nowrap>def$!Abc%$ghi</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Minimal Match</th>
			<td nowrap>def$!<u><span class="marked"><b>Abc</b></span></u>%$ghi</td>
			<td>The minimal match is the tightest one, because $! and %$ are ignored 
			in the target.</td>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Medial Match</th>
			<td nowrap>def$<u><span class="marked"><b>!Abc</b></span></u>%$ghi</td>
			<td>The medial one includes those characters that are binary equal.</td>
		</tr>
		<tr>
			<th style="text-align: right" nowrap>Maximal Match</th>
			<td nowrap>def<u><span class="marked"><b>$!Abc%$</b></span></u>ghi</td>
			<td>The maximal match is the loosest one, including the surrounding 
			ignored characters.</td>
		</tr>
	</table>
	<p>By using minimal, maximal, or medial matches, the issue with ignorables is 
	avoided. Medial matches tend to match user expectations the best.</p>
	<p>When an additional condition is set on the match, the types (minimal, maximal, 
	medial) are based on the matches <i>that meet that condition.</i> Consider 
	the following:</p>
	<table style="BORDER-COLLAPSE: collapse" cellspacing="0" cellpadding="2" border="1">
		<tr>
			<th>&nbsp;</th>
			<th>Value</th>
			<th>Notes</th>
		</tr>
		<tr>
			<th>Pattern:</th>
			<td>abc</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<th>Strength:</th>
			<td><i>primary</i></td>
			<td>thus ignoring combining marks, punctuation</td>
		</tr>
		<tr>
			<th>Text:</th>
			<td>abc<font size="3">¸-°d</font></td>
			<td>two combining marks, cedilla and ring</td>
		</tr>
		<tr>
			<th>Matches:</th>
			<td>|abc|<font size="3">¸|-|°|d</font></td>
			<td>four possible endpoints, indicated by |</td>
		</tr>
	</table>
	<p>Thus if the condition is Whole Grapheme, then the matches are restricted 
	to &quot;abc<font size="3">¸|-°|d&quot;, thus discarding match positions that would not 
	be on a grapheme cluster boundary. Thus the minimal </font>match would be &quot;abc<font size="3">¸|-°d&quot;</font></p>
	<p><b>DS6.</b> The <i>first forward match</i> for P in Q starting at <i>b</i> 
	is the least offset <i>s</i> greater than or equal to <i>b</i> such that for 
	some <i>e</i>, P matches within Q[s,e].</p>
	<p><b>DS7.</b> The <i>first backward match</i> for P in Q starting at <i>b</i> 
	is the greatest offset <i>s</i> less than or equal to <i>b</i> such that for 
	some <i>e</i>, P matches within Q[s,e].</p>
	<p>In DS6 and DS7, matches can be minimal, medial, or maximal; the only requirement 
	is that the combination in use in DS6 and DS7 be specified. Of course, a possible 
	match can also be rejected on the basis of other conditions, such as being grapheme-complete 
	or applying Whole Word Search, as described in [<a href="#UAX29">UAX29</a>]).</p>
	<p>The choice of medial or minimal matches for the &quot;starts with&quot; or &quot;ends with&quot; 
	operations only affects the positioning information for the end of the match 
	or start of the match, respectively.</p>
	<p><b>Special Cases.</b> Ideally, the UCA at a secondary level would be compatible 
	with the standard Unicode case folding and removal of compatibility differences, 
	especially for the purpose of matching. For the vast majority of characters, 
	it is compatible, but there are the following exceptions:</p>
	<ol>
		<li>The UCA maintains compatibility with the DIN standard for sorting German 
		by having the German <i>sharp-s</i> (U+00DF (ß) LATIN SMALL LETTER SHARP 
		S) sort as a secondary difference with &quot;SS&quot;, instead of having ß and SS 
		match at the secondary level.</li>
		<li>Compatibility normalization (NFKC) folds stand-alone accents to a combination 
		of space + combining accent. This was not the best approach, but for backwards 
		compatibility cannot be changed in NFKC. UCA takes a better approach to 
		weighting stand-alone accents, but as a result does not weight them exactly 
		the same as their compatibility decompositions.</li>
		<li>Case-Folding maps <i>iota-subscript</i> (U+0345 (ͅ) COMBINING GREEK 
		YPOGEGRAMMENI) to an iota, due to the special behavior of iota-subscript, 
		while the UCA treats <i>iota-subscript</i> as a regular combining mark (secondary 
		ignorable).</li>
		<li>When compared to their case and compatibility folded values, UCA compares 
		the following as different at a secondary level, whereas other compatibility 
		differences are at a tertiary level.<ul>
			<li>U+017F (ſ) LATIN SMALL LETTER LONG S (and precomposed characters 
			containing it)</li>
			<li>U+1D4C (ᵌ) MODIFIER LETTER SMALL TURNED OPEN E</li>
			<li>U+2D6F (ⵯ) TIFINAGH MODIFIER LETTER LABIALIZATION MARK</li>
		</ul>
		</li>
	</ol>
	<p>In practice, most of these differences are not important for modern text, 
	with one exception: the German ß. Implementations should consider tailoring 
	ß to have a tertiary difference from SS, at least when collation tables are 
	used for matching. Where full compatibility with case and compatibility folding 
	are required, either the text can be preprocessed, or the UCA tables can be 
	tailored to handle the outlying cases.</p>
	<h3>8.1 <a name="Collation_Folding">Collation Folding</a></h3>
	<p>Matching can be done by using the collation elements, directly, as discussed 
	above. However, since matching doesn&#39;t use any of the ordering information, 
	the same result can be achieved by a folding. That is, two strings would fold 
	to the same string if and only if they would match according to the (tailored) 
	collation. For example, a folding for a Danish collation would map both &quot;Gård&quot; 
	and &quot;gaard&quot; to the same value. A folding for a primary-strength folding would 
	map &quot;Resume&quot; and &quot;résumé&quot; to the same value. That folded value is typically 
	a lowercase string, such as &quot;resume&quot;.</p>
	<p>A comparison between folded strings cannot be used for an ordering of strings, 
	but it can be applied to searching and matching quite effectively. The data 
	for the folding can be smaller, because the ordering information does not need 
	to be included. The folded strings are typically much shorter than a sort key, 
	and are human-readable, unlike the sort key. The processing necessary to produce 
	the folding string can also be faster than that used to create the sort key.</p>
	<p>The following is an example of the mappings used for such a folding using 
	to the [<a href="#CLDR">CLDR</a>] tailoring of UCA:</p>
	<p><b>Parameters:</b></p>
	<blockquote>
		<p>{locale=da_DK, strength=secondary, alternate=shifted}</p>
	</blockquote>
	<p><b>Mapping:</b></p>
	<blockquote>
		<table border="1" id="table12" class="noborder" cellspacing="0" cellpadding="3">
			<tr>
				<td colspan="4" class="noborder">...</td>
			</tr>
			<tr>
				<td class="noborder">ª</td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
				<td rowspan="5" class="noborder">Map compatibility (tertiary) equivalents, 
				such as full-width and superscript characters, to representative 
				character(s)</td>
			</tr>
			<tr>
				<td class="noborder">ａ</td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
			</tr>
			<tr>
				<td class="noborder">A </td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
			</tr>
			<tr>
				<td class="noborder">Ａ </td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
			</tr>
			<tr>
				<td class="noborder">ª</td>
				<td class="noborder">→</td>
				<td class="noborder">a</td>
			</tr>
			<tr>
				<td colspan="4" class="noborder">...</td>
			</tr>
			<tr>
				<td class="noborder">å</td>
				<td class="noborder">→</td>
				<td class="noborder">aa</td>
				<td rowspan="2" class="noborder">Map contractions (a + ring above) 
				to equivalent values</td>
			</tr>
			<tr>
				<td class="noborder">Å</td>
				<td class="noborder">→</td>
				<td class="noborder">aa</td>
			</tr>
			<tr>
				<td colspan="4" class="noborder">...</td>
			</tr>
		</table>
	</blockquote>
	<p>Once the table of such mappings is generated, the folding process is a simple 
	longest-first match-and-replace: a string to be folded is first converted to 
	NFD, then at each point in the string, the longest match from the table is replaced 
	by the corresponding result.</p>
	<p>However, ignorable characters need special handling. Characters that are 
	fully ignorable at a given strength level level normally map to the empty string. 
	For example, at <i>strength=quaternary</i>, most controls and format characters 
	map to the empty string; at <i>strength=primary</i>, most combining marks also 
	map to the empty string. In some contexts, however, fully ignorable characters 
	may have an effect on comparison, or characters that aren&#39;t ignorable at the 
	given strength level are treated as ignorable. </p>
	<ol>
		<li>Any discontiguous contractions need to be detected in the process of 
		folding and handled according to Rule <a href="#S2.1">S2.1</a>. For more 
		information about discontiguous contractions, see <i>Section 3.1.1.2,
		<a href="#Contractions">Contractions</a>.</i></li>
		<li>An ignorable character may interrupt what would otherwise be a contraction. 
		For example, suppose that &quot;ch&quot; is a contraction sorting after &quot;h&quot;, as in 
		Slovak. In the absence of special tailoring, a CGJ or SHY between the &quot;c&quot; 
		and the &quot;h&quot; prevents the contraction from being formed, and causes &quot;c&lt;CGJ&gt;h&quot; 
		to not compare as equal to &quot;ch&quot;. If the CGJ is simply folded away, they 
		would incorrectly compare as equal. See also <i>Section 3.1.6,
		<a href="#Combining_Grapheme_Joiner">Combining Grapheme Joiner</a></i>.</li>
		<li>With the parameter values <i>alternate=shifted</i> or <i>alternate=blanked</i>, 
		any (partially) ignorable characters after Variables have their weights 
		reset to zero at levels 1 to 3, and may thus become fully ignorable. In 
		that context, they would also be mapped to the empty string. For more information, 
		see <i>Section 3.2.2, <a href="#Variable_Weighting">Variable Weighting</a>.</i></li>
	</ol>
  <h2>Appendix A: <a name="Deterministic_Sorting">Deterministic Sorting</a></h2>
	<p>There is often a good deal of confusion about what is meant by the terms 
	&quot;stable&quot; or &quot;deterministic&quot; when applied to sorting or comparison. This confusion 
	in terms often leads people to make mistakes in their software architecture, 
	or make choices of language-sensitive comparison options that have significant 
	impact in terms of performance and footprint, and yet do not give the results 
	that users expect.</p>
	<h3>A.1 <a name="Stable_Sort">Stable Sort</a></h3>
	<p>A stable sort is one where two records will retain their order when sorted 
	according to a particular field, even when the two fields have the same contents. 
	Thus those two records come out in the same relative order that they were in 
	before sorting, although their positions relative to other records may change. 
	Importantly, this is a property of the sorting algorithm, <i>not</i> the comparison 
	mechanism.</p>
	<p>Two examples of differing sorting algorithms are Quick Sort and Merge. Quick 
	Sort is not stable while Merge Sort is stable. (A Bubble Sort, as typically 
	implemented, is also stable.)</p>
	<ul>
		<li>For background on the names and characteristics of different sorting 
		methods, see [<a href="#SortAlg">SortAlg</a>] </li>
		<li>For a definition of stable sorting, see [<a href="#Unstable">Unstable</a>]
		</li>
	</ul>
	<p>&nbsp;Suppose that you have the following records and you sort on the Last_Name 
	field only:</p>
	<div align="center">
		<center>
		<table cellspacing="0" cellpadding="4" border="1" id="table1">
			<caption>Original Records</caption>
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
		</table>
		</center></div>
	<h4>&nbsp;</h4>
	<div align="center">
		<center>
		<table cellspacing="0" cellpadding="4" border="1" id="table2">
			<caption>Merge Sort Results</caption>
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
		</table>
		</center></div>
	<h4>&nbsp;</h4>
	<div align="center">
		<center>
		<table cellspacing="0" cellpadding="4" border="1" id="table3">
			<caption>Quick Sort Results</caption>
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#ff0000">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
			<tr>
				<td><font color="#ff0000">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
		</table>
		</center></div>
	<p>As you see from the above, the Quicksort algorithm is not stable; the records 
	1 and 2 are not in the same order they were in before sorting.</p>
	<p>A stable sort is often desired; for one thing, it allows records to be successively 
	sorting according to different fields, and retain the correct lexigraphic order. 
	Thus with a stable sort, one could all the records by First_Name, then sort 
	all the records by Last_Name, giving the desired results: that all records would 
	be sorted by Last_Name, and where the Last_Names are the same, sorted by First_Name.</p>
	<h3>A.2 <a name="Deterministic_Sort">Deterministic Sort</a></h3>
	<p>A <i>deterministic</i> sort is a very different beast. This is a sort algorithm 
	that returns the same results each time. On the face of it, it would seem odd 
	for any sort algorithm to <i>not</i> be deterministic, but there are examples 
	of real-world sort algorithms that aren&#39;t.</p>
	<p>The key concept is that these sort algorithms <i>are</i> deterministic when 
	two records have unequal fields, but they may return different results at different 
	times when two records have equal fields.</p>
	<p>For example, a classic Quick Sort algorithm works recursively on ranges of 
	records. For any given range of records, it takes the first element as the
	<i>pivot element</i>. We&#39;re not going to explain the details here, but that 
	algorithm performs badly with input data that happens to be sorted (or mostly 
	sorted). A randomized Quick Sort, which picks a random element as the pivot, 
	can on average be faster. The results it gets are not deterministic; from <i>
	exactly </i>the same input, different results can be output:</p>
	<div align="center">
		<center>
		<table class="noborder" cellspacing="0" cellpadding="4" border="0" id="table4">
			<caption>Enhanced Quick Sort Results</caption>
			<tr>
				<td class="noborder">
				<table cellspacing="0" cellpadding="4" border="1" id="table5">
					<tr>
						<th>Record</th>
						<th>Last_Name</th>
						<th>First_Name</th>
					</tr>
					<tr>
						<td>3</td>
						<td>Curtner</td>
						<td>Fred</td>
					</tr>
					<tr>
						<td><font color="#ff0000">2</font></td>
						<td>Davis</td>
						<td>John</td>
					</tr>
					<tr>
						<td><font color="#ff0000">1</font></td>
						<td>Davis</td>
						<td>Mark</td>
					</tr>
				</table>
				</td>
				<td class="noborder">
				<p align="center">or</p>
				</td>
				<td class="noborder">
				<table cellspacing="0" cellpadding="4" border="1" id="table6">
					<tr>
						<th>Record</th>
						<th>Last_Name</th>
						<th>First_Name</th>
					</tr>
					<tr>
						<td>3</td>
						<td>Curtner</td>
						<td>Fred</td>
					</tr>
					<tr>
						<td><font color="#00ff00">1</font></td>
						<td>Davis</td>
						<td>Mark</td>
					</tr>
					<tr>
						<td><font color="#00ff00">2</font></td>
						<td>Davis</td>
						<td>John</td>
					</tr>
				</table>
				</td>
			</tr>
		</table>
		</center></div>
	<p>As another example, multiprocessor sorting algorithms can be non-deterministic. 
	The work of sorting different blocks of data are farmed out to different processors 
	and then merged back together. The ordering of records with equal fields might 
	be different according to when different processors finish different tasks.</p>
	<p>Note that a deterministic sort is weaker than a stable sort. A stable sort 
	is always deterministic, but not vice versa. And typically when people say they 
	want a deterministic sort, they really mean that they want a stable sort.</p>
	<h3>A.3 <a name="Deterministic_Comparison">Deterministic Comparison</a></h3>
	<p>A <i>deterministic comparison</i> is different than either of the above; 
	it is a property of a comparison function, <i>not</i> a sorting algorithm. This 
	is a comparison where strings that do not have identical binary contents (optionally, 
	after some process of normalization) will compare as unequal. A deterministic 
	comparison is sometimes called a <i>stable</i> (or <i>semi-stable</i>) <i>comparison</i>.</p>
	<p>There are many people who confuse a deterministic comparison with a deterministic 
	(or stable) sort, but once again, these are <i>very</i> different creatures. 
	A comparison is used by a sorting algorithm to determine the relative ordering 
	of two fields, such as strings. Using a deterministic comparison <i>cannot</i> 
	cause a sort to be deterministic, nor to be stable. Whether a sort is deterministic 
	or stable is a property of the sort algorithm, <i>not</i> the comparison function. 
	If you look at the examples above, this is clear.</p>
	<h4>A.3.1 <a name="Forcing_Deterministic_Comparisons">Forcing Deterministic 
	Comparisons</a></h4>
	<p>One can produce a deterministic comparison function from a non-deterministic 
	one, in the following way (in pseudo-code):</p>
	<pre>int new_compare (String a, String b) {
  int result = old_compare(a, b);
  if (result == 0) {
    result = binary_compare(a, b);
  }
  return result;
}</pre>
	<p>Programs typically also provide the facility to generate a <i>sort key</i>, 
	which is a sequences of bytes generated from a string in alignment with a comparison 
	function. Two sort keys will binary-compare in the same order as their original 
	strings.&nbsp; To create a deterministic sort key that aligns with the above
	<code>new_compare</code>, the simplest means is to append a copy of the original 
	string to the sort key. This will force the comparison to be deterministic.</p>
	<pre>byteSequence new_sort_key (String a) {
  return old_sort_key(a) + SEPARATOR + toByteSequence(a);
}</pre>
	<p>Because sort keys and comparisons must be aligned, a sort key generator is 
	deterministic if and only if a comparison is.</p>
	<h4>A.3.2 <a name="Best_Practice">Best Practice</a></h4>
	<p>However, a deterministic comparison is generally not best practice. First, 
	it has a certain performance cost in comparison, and a quite substantial impact 
	on sort key size. (For example, ICU language-sensitive sort keys are generally 
	about the size of the original string, so appending a copy of the original string 
	generally <i>doubles</i> the size of the sort key.)&nbsp; A database using these 
	sort keys can have substantially increased disk footprint and memory footprint, 
	and consequently reduced performance.</p>
	<p>More importantly, a deterministic comparison function does not actually achieve 
	the effect people think it will have. Look at the sorted examples above. Whether 
	a deterministic comparison is use or not, there will be <i><b>no</b></i> effect 
	on Quick Sort example, since the two records in question have identical last 
	name fields. It does not make a non-deterministic sort into a deterministic 
	one, nor does it make a non-stable sort into a stable one.</p>
	<p>Thirdly, a deterministic comparison is often not what is wanted, when people 
	look closely at the implications. Look at our above example, and suppose that 
	this time the user is sorting first by last name, then by first name.</p>
	<div align="center">
		<center>
		<table cellspacing="0" cellpadding="4" border="1" id="table7">
			<caption>Original Records</caption>
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
		</table>
		</center></div>
	<p>The desired results are the following, which should result whether the sorting 
	algorithm is stable or not, since we are using both fields.</p>
	<div align="center">
		<center>
		<table cellspacing="0" cellpadding="4" border="1" id="table8">
			<caption>Last then First</caption>
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
		</table>
		</center></div>
	<p>Now suppose that in record 2, the source for the data caused the last name 
	to contain a control character, such as a ZWJ (used to request ligatures on 
	display). There is in this case no visible distinction in the forms, since the 
	font doesn&#39;t have any ligatures for these values. The standard UCA collation 
	sequence causes that character to be—correctly—ignored in comparison, since 
	it should only affect rendering. However, if that comparison is changed to be 
	deterministic (by appending the binary original string, then unexpected results 
	will occur.</p>
	<div align="center">
		<center>
		<table cellspacing="0" cellpadding="4" border="1" id="table9">
			<caption>Last then First<br>
			(Deterministic)</caption>
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#ff0000">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
			<tr>
				<td><font color="#ff0000">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
		</table>
		</center></div>
	<h4>A.3.3 <a name="Forcing_Stable_Sorts">Forcing Stable <i>Sorts</i></a></h4>
	<p>Typically, what people really want when they say they want a deterministic 
	comparison is actually a stable sort.</p>
	<p>One <i>can</i> force non-stable sorting algorithm to produce stable results 
	by how one does the comparison. However, it has literally nothing to do with 
	making the comparison be deterministic or not. Instead, it can be done by appending 
	the <i>current record number</i> to the strings to be compared. (The implementation 
	may not actually append the number; it may use some other mechanism, but the 
	effect would be the same.)</p>
	<p>If such a modified sort comparison is used, for example, then it forces Quick 
	Sort to get the same results as Merge Sort. And in that case, the irrelevant 
	character ZWJ does not affect the outcome, as illustrated below, and the correct 
	results occur.</p>
	<div align="center">
		<center>
		<table cellspacing="0" cellpadding="4" border="1" id="table10">
			<caption>Last then First<br>
			(Forced Stable Results)</caption>
			<tr>
				<th>Record</th>
				<th>Last_Name</th>
				<th>First_Name</th>
			</tr>
			<tr>
				<td>3</td>
				<td>Curtner</td>
				<td>Fred</td>
			</tr>
			<tr>
				<td><font color="#00ff00">1</font></td>
				<td>Davis</td>
				<td>John</td>
			</tr>
			<tr>
				<td><font color="#00ff00">2</font></td>
				<td>Davis</td>
				<td>Mark</td>
			</tr>
		</table>
		</center></div>
	<p>If anything, this then is what users want when they say they want a deterministic 
	comparison. See also <i>Section 1.6, <a href="#Interleaved_Levels">Interleaved 
	Levels</a></i>.</p>
	
	<h3>A.4 <a name="Stable_Comparison">Stable Comparison</a></h3>
	
	<p>There are a few other terms worth mentioning, simply because they are also 
	subject to considerable confusion. Any or all of the following may be easily 
	confused with above.</p>
	<p>A <i>stable comparison</i> is one that does not change over successive software 
	versions. That is, as one uses successive versions of an API, with the same 
	&quot;settings&quot; (such as locale), one gets the same results.</p>
	<p>A <i>stable sort key generator</i> is one that generates the same binary 
	sequence over successive software versions.</p>
	<blockquote>
		<p><b>Warning: </b>if the sort key generator is stable, then the associated 
		comparison will perforce be. However, the reverse is not guaranteed. To 
		take a trivial example, suppose the new version of the software always adds 
		an 0xFF byte at the front of every sort key. The results of any comparison 
		of any two <i>new</i> keys would be identical to the results of the comparison 
		of any two corresponding <i>old</i> keys. But the bytes have changed, and 
		the comparison of old and new keys would give different results. Thus one 
		can have a stable comparison, yet an associated non-stable sort key generator.</p>
	</blockquote>
	<p>A <i>portable comparison</i> is where corresponding APIs for comparison produce 
	the same results across different platforms. That is, if one uses the same &quot;settings&quot; 
	(such as locale), one gets the same results.</p>
	<p>A <i>portable sort key generator </i>is where corresponding sort key APIs 
	produce exactly the same sequence of bytes across different platforms.</p>
	<blockquote>
		<p><b>Warning: </b>as above, a comparison may be portable without the associated 
		sort key generator being portable.</p>
	</blockquote>
	<p>Ideally, all products would have the same string comparison and sort key 
	generation for, say Swedish, and thus be portable. For historical reasons, this 
	is not the case. Even if the main letters sort the same, there will be differences 
	in the handling of other letters, or symbols, punctuation, and other characters. 
	There are some libraries that offer portable comparison, such as [<a href="#ICUCollator">ICU</a>], 
	but in general the results of comparison or sort key generation may vary significantly 
	between different platforms.</p>
	<p>In a closed system, or in simple scenarios, portability may not matter. Where 
	someone has a given set of data to present to a user, and just wants the output 
	to be reasonably appropriate for Swedish, then the exact order on the screen 
	may not matter.</p>
	<p>In other circumstances, it can lead to data corruption. For example, suppose 
	that two implementations do a database SELECT for records between a pair of 
	strings. If the collation is different in the least way, they can get different 
	data results. Financial data might be different, for example, if a city is included 
	in one SELECT on one platform and excluded from the same SELECT on another platform.</p>
	<h2><a name="Acknowledgements">Acknowledgements</a></h2>
	<p>Thanks to Bernard Desgraupes, Richard Gillam, Kent Karlsson, York Karsunke, Michael Kay, 
	Åke Persson, Roozbeh Pournader, Markus Scherer, Javier Sola, Otto Stolz, Ienup Sung, Yoshito Umaoka, Andrea Vine, and 
	Vladimir Weinstein for their feedback on previous versions of this document, 
	to Jianping Yang and Claire Ho for their contributions on matching, and to Cathy 
	Wissink for her many contributions to the text.</p>
<h2><a name="References">References</a></h2>
	<table class="noborder" cellpadding="8">
		<tr>
			<td width="1" class="noborder">[<a name="AllKeys">AllKeys</a>]</td>
			<td class="noborder">
			<p>The latest approved version of this file is:<br>
			<a href="http://www.unicode.org/Public/UCA/latest/allkeys.txt">http://www.unicode.org/Public/UCA/latest/allkeys.txt</a></p>
			<p>The version at the time of 
			this publication is:<br>
			<a href="http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt">http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt</a></p>
			<p><i>Note:</i> ftp access is available, starting at:<br>
			<a href="ftp://www.unicode.org/Public/UCA/">ftp://www.unicode.org/Public/UCA/</a></p>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="CanStd">CanStd</a>]</td>
			<td class="noborder">CAN/CSA Z243.4.1</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="CLDR">CLDR</a>]</td>
			<td class="noborder"><i>Common Locale Data Repository<br>
			<a href="http://unicode.org/cldr/">http://unicode.org/cldr/</a> </i>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="FAQ">FAQ</a>]</td>
			<td class="noborder">Unicode Frequently Asked Questions<br>
			<a href="http://www.unicode.org/faq/">http://www.unicode.org/faq/<br>
			</a><i>For answers to common questions on technical issues.</i></td>
		</tr>
		<tr>
			<td valign="top" width="1" class="noborder">[<a name="Feedback">Feedback</a>]</td>
			<td valign="top" class="noborder">Reporting Errors and Requesting Information 
			Online<i><br>
			</i><a href="http://www.unicode.org/reporting.html">http://www.unicode.org/reporting.html</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Glossary">Glossary</a>]</td>
			<td class="noborder">Unicode Glossary<a href="http://www.unicode.org/glossary/"><br>
			http://www.unicode.org/glossary/<br>
			</a><i>For explanations of terminology used in this and other documents.</i></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="ICUCollator">ICUCollator</a>]</td>
			<td class="noborder">ICU User Guide: Collation Introduction<br>
			<a href="http://icu.sourceforge.net/userguide/Collate_Intro.html">http://icu.sourceforge.net/userguide/Collate_Intro.html</a>
			</td>
		</tr>
		<tr>
			<td class="noborder" valign="top" width="1">[<a name="ISO14651">ISO14651</a>]</td>
			<td class="noborder" valign="top">International Organization for Standardization.
			<i>Information Technology--International String ordering and comparison--Method 
			for comparing character strings and description of the common template 
			tailorable ordering.&nbsp; </i>(ISO/IEC 14651:2001). <i>For availability 
			see <a href="http://www.iso.org">http://www.iso.org</a></i></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="JavaCollator">JavaCollator</a>]</td>
			<td class="noborder">
			<a href="http://java.sun.com/j2se/1.4/docs/api/java/text/Collator.html">
			http://java.sun.com/j2se/1.4/docs/api/java/text/Collator.html</a>,<br>
			<a href="http://java.sun.com/j2se/1.4/docs/api/java/text/RuleBasedCollator.html">
			http://java.sun.com/j2se/1.4/docs/api/java/text/RuleBasedCollator.html</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="LDML">LDML</a>]</td>
			<td class="noborder">UTS #35: <i>Locale Data Markup Language (LDML)</i><br>
			<a href="http://www.unicode.org/reports/tr35/">http://www.unicode.org/reports/tr35/</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Reports">Reports</a>]</td>
			<td class="noborder">Unicode Technical Reports<br>
			<a href="http://www.unicode.org/reports/">http://www.unicode.org/reports/<br>
			</a><i>For information on the status and development process for technical 
			reports, and for a list of technical reports.</i></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Sample">Sample</a>]</td>
			<td class="noborder">
			<a href="http://www.unicode.org/reports/tr10/Sample/">http://www.unicode.org/reports/tr10/Sample/</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Test">Test</a>]</td>
			<td class="noborder">The latest approved versions of these files are:<br>
			<a href="http://www.unicode.org/Public/UCA/latest/CollationTest.html">
			http://www.unicode.org/Public/UCA/latest/CollationTest.html<br>
			</a>
			<a href="http://www.unicode.org/Public/UCA/latest/CollationTest.zip">
			http://www.unicode.org/Public/UCA/latest/CollationTest.zip</a><p>The 
			versions at the time of this publication are:<br>
			<a href="http://www.unicode.org/Public/UCA/5.2.0/CollationTest.html">
			http://www.unicode.org/Public/UCA/5.2.0/CollationTest.html</a><br>
			<a href="http://www.unicode.org/Public/UCA/5.2.0/CollationTest.zip">
			http://www.unicode.org/Public/UCA/5.2.0/CollationTest.zip</a></p>
			<p><i>Note:</i> ftp access is available, starting at:<br>
			<a href="ftp://www.unicode.org/Public/UCA/">ftp://www.unicode.org/Public/UCA/</a></p>
			</td>
		</tr>
		<tr>
			<td class="noborder">[<a name="SortAlg">SortAlg</a>]</td>
			<td class="noborder">For background on the names and characteristics 
			of different sorting methods, see<br>
			<a href="http://www.aeriesoft.ru/Projects/SortAlg/">http://www.aeriesoft.ru/Projects/SortAlg/</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="UAX15">UAX15</a>]</td>
			<td class="noborder">UAX #15: Unicode Normalization Forms<br>
			<a href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="UAX29">UAX29</a>]</td>
			<td class="noborder">UAX #29: Unicode Text Segmentation<br>
			<a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="UAX44">UAX44</a>]</td>
			<td class="noborder">UAX #44: Unicode Character Database<br>
			<a href="http://www.unicode.org/reports/tr44/">
			http://www.unicode.org/reports/tr44/</a>
			</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Unicode">Unicode</a>]</td>
			<td class="noborder">The Unicode Consortium. The Unicode Standard, 
			Version 5.2.0, defined by: <i>The Unicode Standard, Version 5.2</i> 
			(Mountain View, CA: The Unicode Consortium, 2009. ISBN 
			978-1-936213-00-9) (<a href="http://www.unicode.org/versions/Unicode5.2.0/">http://www.unicode.org/versions/Unicode5.2.0/</a>).</td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="UTN5">UTN5</a>]</td>
			<td class="noborder">UTN #5: Canonical Equivalence in Applications<br>
			<a href="http://www.unicode.org/notes/tn5/">http://www.unicode.org/notes/tn5/</a>
			</td>
		</tr>
		<tr>
		  <td width="1" class="noborder">[<a name="UTS18">UTS18</a>]</td>
			<td class="noborder">UTS #18: Unicode Regular Expressions<br>
			<a href="http://www.unicode.org/reports/tr18/">http://www.unicode.org/reports/tr18/</a>
			</td>
		</tr>
		<tr>
			<td class="noborder">[<a name="Unstable">Unstable</a>]</td>
			<td class="noborder">For a definition of stable sorting, see<br>
			<a href="http://planetmath.org/encyclopedia/UnstableSortingAlgorithm.html">
			http://planetmath.org/encyclopedia/UnstableSortingAlgorithm.html</a></td>
		</tr>
		<tr>
			<td width="1" class="noborder">[<a name="Versions">Versions</a>]</td>
			<td class="noborder">Versions of the Unicode Standard<br>
			<a href="http://www.unicode.org/versions/">http://www.unicode.org/versions/<br>
			</a><i>For details on the precise contents of each version of the Unicode 
			Standard, and how to cite them.</i></td>
		</tr>
	</table>
	<p>&nbsp; </p>
	<h2><a name="Modifications">Modifications</a></h2>
	<p>The following summarizes modifications from the previous revisions of this 
	document.</p>
	<h3>Revision 20</h3>
		<ul>
			<li>Updated for Unicode 5.2.0.
			<li>In 7.1.3 <a href="#Implicit_Weights">Implicit Weights</a>, clarified the calculation of implicit weights.</li>
			<li>Made it clear that the BASE value does not include unassigned code points.</li>
			<li>Clarified why some sample cells are empty in the first table.</li>
			<li>General: updated references to UAX/UTS's</li>
			<li>Removed reference to UTR#30</li>
			<li>Better aligned the options with the 3 values for variableChoice.</li>
			<li>Clarified the computation of the fourth level in Section 3.2.1. [KW]</li>
			<li>Changed bit layout in Section 6.10.1 for a real collation element,
			    to account for the fact that the DUCET secondary values number
			    more than 255, so no longer fit in 8 bits. [KW]</li>
			<li>Made small editorial clarifications regarding variable weighting in Section 3.2.2. [KW]</li>
			<li>Updated reference to SC22 WG20 to SC2 OWG-SORT in Section 7.1.4.1. [KW]</li>
			<li>Made a minor wording clarification in Section 7.3. [KW]</li>
			<li>Small editorial updates through for formatting consistency. [KW]</li>
			<li>Updated Modifications section to current conventions for handling
			    proposed update drafts. [KW]</li>
		</ul>
	<p>Revision 20 being a proposed update, only changes between revisions 20 and 18 are noted here.</p>
	<h3>Revision 18</h3>
	<ul>
		<li>Updated for Unicode 5.1.0.
		<li>Disallowed skipping 2.1.1 through 2.1.3 (<i>Section 4.2,
			<a href="#Step_2">Produce Array</a></i>).</li>
		<li>Clarified use of contractions in the DUCET in <i>Section 3.2,
		<a href="#Default_Unicode_Collation_Element_Table">Default Unicode Collation 
			Element Table</a></i> and <i>Section 3.1.1.2, <a href="#Contractions">Contractions</a></i>.</li>
		<li>Added information about the use of parameterization (<i>Section 5.1,
			<a href="#Parametic_Tailoring">Parametric Tailoring</a></i>) and a new 
			conformance clause <a href="#C6">C6</a>.</li>
		<li>In <i>Section 8, <a href="#Searching">Searching and Matching</a></i>,
			added new introduction and explained special cases; clarified 
		language in definitions.</li>
		<li>Added <i>Section 8.1, <a href="#Collation_Folding">Collation Folding</a></i>.</li>
		<li>Fixed a number of reported typos.</li>
	</ul>
	<p>Revision 17 being a proposed update, only changes between revisions 18 and 16 are noted here.</p>
	<h3>Revision 16</h3>
	<ul>
		<li>Updated for Unicode 5.0.0.
		<li>Replaced &quot;combining mark&quot; by &quot;non-starter&quot; where necessary.</li>
		<li>Updated reference to Unicode 5.0 with the ISBN number.</li>
		<li>Added UTN#9 text in informative appendix as <i>
		<a href="#Deterministic_Sorting">Appendix A: Deterministic_Sorting</a></i>.</li>
	</ul>
	<p>Revision 15 being a proposed update, only changes between revisions 16 and 14 are noted here.</p>
	<h3>Revision 14</h3>
	<ul>
		<li>Updated for Unicode 4.1.0.
		<li>Expanded use of 0x1D in <i>Section 
		7.3.1, <a href="#Tertiary_Weight_Table">Tertiary Weight Table</a></i>.</li>
		<li>Removed DS5, added DS1a, DS2a, explanations of interactions with other 
		conditions, such as Whole Word or Whole Grapheme.</li>
		<li>Added conformance clause C5 for searching and matching.</li>
		<li>Many minor edits.</li>
		<li>Removed S1.3, so that fully ignorable characters will interrupt contractions 
		(that do not explicitly contain them).</li>
		<li>Added related <i>Section 3.1.6, 
		<a href="#Combining_Grapheme_Joiner">Combining Grapheme Joiner</a></i>.</li>
		<li>Removed S1.2 for Thai, and a paragraph in 1.3.</li>
		<li>Added more detail about Hangul to <i>Section 
		7.1.4, <a href="#Trailing_Weights">Trailing Weights</a></i>, including a description of the Interleaving 
		method.</li>
		<li>Fixed dangling reference to base standard in <a href="#C4">C4</a>.</li>
		<li>Added definitions and clarifications to <i>Section 
		8, <a href="#Searching">Searching and Matching</a></i>.</li>
		<li>Added more information on user expectations to <i>
		Section 1, <a href="#Introduction">Introduction</a></i>.</li>
	</ul>
	<p>Data tables for 4.1.0 contain the following changes:</p>
	<ol>
		<li>The additions of weights for all the new Unicode 4.1.0 characters.</li>
		<li>The change of weights for characters Æ, Ǽ, Ǣ; Đ, Ð; Ħ; Ł, Ŀ; and Ø, 
		Ǿ (and their lowercase and accented forms) to have secondary (accent) differences 
		from AE; D; H; L; and O, respectively. This is to provide a much better 
		default for languages in which those characters are not tailored. See also 
		the section on user expectations.</li>
		<li>Change in weights for U+0600 ARABIC NUMBER SIGN and U+2062 INVISIBLE 
		TIMES and like characters (U+0600..U+0603, U+06DD, U+2061..U+2063) to be 
		not completely ignorable, because their effect on the interpretation of 
		the text can be substantial.</li>
		<li>The addition of about 150 contractions for Thai. This is synchronized 
		with the removal of S1.2. The result produces the same results for well-formed 
		Thai data, while substantially reducing the complexity of implementations 
		in searching and matching. Other changes for Thai include:<ol type="a">
			<li>After U+0E44 ไ THAI CHARACTER SARA AI MAIMALAI<br>
			Insertion of the character U+0E45 ๅ THAI CHARACTER LAKKHANGYAO</li>
			<li>Before U+0E47&nbsp; ็ THAI CHARACTER MAITAIKHU<br>
			Insertion of the character U+0E4E ๎ THAI CHARACTER YAMAKKAN</li>
			<li>After U+0E4B ๋ THAI CHARACTER MAI CHATTAWA<br>
			Insertion of the character U+0E4C ์ THAI CHARACTER THANTHAKHAT<br>
			Then the character U+0E4D ํ THAI CHARACTER NIKHAHIT</li>
		</ol>
		</li>
		<li>Changed the ordering of U+03FA GREEK CAPITAL LETTER SAN and U+03FB GREEK 
		SMALL LETTER SAN.</li>
	</ol>
	<p>Revisions 12 and 13 being proposed updates, only changes between revisions 14 and 11 are noted here.</p>
	<h3>Revision 11</h3>
	<ul>
		<li>Changed the version to synchronize with versions of the Unicode Standard, 
		so that the repertoire of characters is the same. This affects the header 
		and <a href="#C4">C4</a>. This revision is synchronized
		with Unicode 4.0.0.</li>
		<li>Location of data files changed to
		<a href="http://www.unicode.org/Public/UCA/">http://www.unicode.org/Public/UCA/</a></li>
		<li>Added new <a href="#Introduction">Introduction</a>. This covers concepts 
		in <i>Section 5.17</i>, 
		"Sorting and Searching", in  
		 <i>The Unicode Standard,
		Version 3.0</i>, but is completely reworked. The Scope section 
		has been recast and is now at the end of the introduction.</li>
		<li>In <i>Section 6.9, <a href="#Comparison_to_Java">Tailoring Example: Java</a></i>, added 
		informative reference to LDML; moved informative reference to ICU.</li>
		<li>Added explanation of different ways that the Hangul problem can be solved 
		in <i>Section 7.1.4, <a href="#Trailing_Weights">Trailing Weights</a></i>.</li>
		<li>Copied sentence from Scope up to Summary, for more visibility.</li>
	</ul>
	<p>Revision 10 being a proposed update, only changes between revisions 11 and 9 are noted here.</p>
	<h3>Revision 9</h3>
	<ul>
		<li>Added <a href="#C4">C4</a>.</li>
		<li>Added more conditions in <i>Section 3.3, <a href="#Well-Formed">Well-Formed Collation 
		Element Tables</a></i>.</li>
		<li>Added S1.3.</li>
		<li>Added treatment of ignorables after variables in
		<i>Section 3.2.2, <a href="#Variable_Weighting">Variable Weighting</a></i>.</li>
		<li>Added <i>Section 3.4, <a href="#Stability">Stability</a></i>.</li>
		<li>Modified and reorganized <i>Section 7, <a href="#Weight_Derivation">Weight Derivation</a></i>. 
		In particular, CJK characters and unassigned characters are given different 
		weights. Added MAX to <i>Section 7.3</i>.</li>
		<li>Added references.</li>
		<li>Minor editing.</li>
		<li>Clarified noncharacter code points in 
		<i>Section 7.1.1, <a href="#Illegal_Code_Points">Illegal code points</a></i>.</li>
		<li>Modified S1.2 and <i>Section 3.1.3, <a href="#Rearrangement">Rearrangement</a></i> to 
		use the Logical_Order_Exception property, and removed <i>rearrange</i> from 
		the file syntax in <i>Section 3.2.1, <a href="#File_Format">File Format</a></i>, and from
		<i>Section 5, <a href="#Tailoring">Tailoring</a></i>.</li>
		<li>Incorporated Cathy Wissink&#39;s notes on linguistic applicability.</li>
		<li>Updated links for [<a href="#Test">Test</a>].</li>
	</ul>
	<hr width="50%">
	<p class="copyright"><font size="-1">Copyright © 1998-2009 Unicode, Inc. All 
	Rights Reserved. The Unicode Consortium makes no expressed or implied warranty 
	of any kind, and assumes no liability for errors or omissions. No liability 
	is assumed for incidental and consequential damages in connection with or arising 
	out of the use of the information or programs contained or accompanying this 
	technical report. The Unicode
	<a href="http://www.unicode.org/copyright.html">Terms of Use</a> apply.</font>
	</p>
	<p class="copyright"><font size="-1">Unicode and the Unicode logo are trademarks 
	of Unicode, Inc., and are registered in some jurisdictions.</font></p>
</div>

</body>

</html>
