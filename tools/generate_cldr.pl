#!/usr/bin/perl
use strict;
use warnings;
use 5.010;
use Carp;
use FindBin qw($Bin);
use File::Spec;
use File::Slurp;
use List::Util qw(first);
use IO::File;
use XML::LibXML;
#use Template::Tiny;
use Data::Dump;
use Perl::Tidy;
#use Text::Wrap;
#$Text::Wrap::columns = 10000;

binmode(STDOUT, ':utf8');

my %operators = (
    p       => '<',
    s       => '<<',
    t       => '<<<',
    q       => '<<<<',
    i       => '=',
    extend  => '/',
    context => '|'
);
# "q" is not explained in UTS#35 but stands obviously for "quaternary"
# it is currently only used in th.xml (Thai)

my %levelNames = (
    primary    => 1,
    secondary  => 2,
    tertiary   => 3,
    quaternary => 4,
    identical  => 5
);

my @settingsOK = qw/
    strength alternate backwards normalization caseLevel caseFirst
    hiraganaQuaternary numeric variableTop match-boundaries match-style
    /;

my %settingsAliases = (
    strength => 'level',
    alternate => 'variable'
);

#TODO map on/off to 1/0
#TODO "caseFirst = upper" => 'upper_before_lower = 1'

#TODO implement these in U::C
my @settingsUnimplemented = qw/
    caseLevel hiraganaQuaternary numeric
    variableTop match-boundaries match-style
    /;

#TODO: these are not implemented in U::C yet
my @logicalResets = qw/
    first_variable last_variable first_tertiary_ignorable
    last_tertiary_ignorable first_secondary_ignorable
    last_secondary_ignorable first_primary_ignorable
    last_primary_ignorable first_non_ignorable
    last_non_ignorable first_trailing last_trailing
    /;

my @ldml_files = glob(File::Spec->catfile($Bin, qw(.. data CLDR collation), "*.xml"));

croak "Could not find LDML files" unless @ldml_files;

# to store all parsed data
my %tailorings;
my %aliases;
my %aliases_with_type;
my @available_locales;

# templates to use with Template::Tiny
#my $Locale_ID_tt = read_file("Locale_ID.tt");
#my $Locale_Data_tt = read_file("Locale_Data.tt");

my $CLDR_Version_File = File::Spec->catfile($Bin, qw(.. data CLDR VERSION));

my $CLDR_Version = read_file($CLDR_Version_File)
    or croak "Cannot read $CLDR_Version_File\nThis file needs to be created manually after unpacking the CLDR zip archive, and should only contain the CLDR release number";

chomp $CLDR_Version;

#my $locale = $ARGV[0] || "sv";
#my $infile = File::Spec->catfile($Bin, qw(.. data CLDR collation), "$locale.xml");

my $parser = XML::LibXML->new();

#my $tt = Template::Tiny->new;

my $COMMENT_HEADER =<<END;
# This package was auto-generated by tools/cldr_generate.pl
# included in the forked distribution of the CPAN module
# Unicode::Collate at http://github.com/fc7/Unicode-Collate
# using the collation data in CLDR version $CLDR_Version

END

my $Locale_Dir = File::Spec->catfile($Bin, qw(.. lib Unicode Collate Locale));

if (-d $Locale_Dir) {
    my @locdirfiles = glob(File::Spec->catfile($Locale_Dir, '*.pm'));
    unlink @locdirfiles
        or croak "cannot remove '*.pm' files under $Locale_Dir"
}
else {
    mkdir $Locale_Dir
        or croak "Cannot mkdir $Locale_Dir";
}

#############################################################
sub parse_ldml {
    my $xpc       = shift;
    my $locale_id = shift;
    my $tailoring = {};

    # get revision number of the LDML collation file
    my $version = $xpc->findvalue('/ldml/identity/version/@number');
    $version =~ s/^\$Revision:\s*//;
    $version =~ s/\s*\$$//;

    $tailoring->{version} = $version;

    #catch '/ldml/collations/default'
    if ( $xpc->exists('/ldml/collations/default') ) {
        my $default = $xpc->findvalue('/ldml/collations/default/@type');
        #...
        $tailoring->{default_type} = $default;
        ## check that the default_type exists, else it must point to the main locale
        # NB: currently this only affects
        # "zh_Hant" pointing to "zh@stroke" (locale "zh" with collation type "stroke")
        if (! $xpc->exists("/ldml/collations/collation[\@type = \"$default\"]") ) {
            my ($mainloc) = $locale_id =~ /^([a-z]+)_/;
            if ( defined $tailorings{$mainloc} and
                 defined $tailorings{$mainloc}{$default} ) {
                $aliases_with_type{$locale_id} = [ $mainloc, $default ];
            }
            return
        }
    }

    my $collnodes = $xpc->findnodes('/ldml/collations/collation');

    #my @colltypes;
    my %types_seen = ();
    my %types_alt  = ();

    foreach my $c ($collnodes->get_nodelist) {

        my $type = $c->findvalue('@type') || 'default';
        $types_seen{$type}++;

        #TODO check for uniqueness of node of this type

        #TODO ignore @alt unless there are more than one of the same @type
        my $alt;
        if ($c->exists('@alt')) {
            $alt  = $c->findvalue('@alt') ;
            $types_alt{$type} = $alt
        }

        if ($types_seen{$type} > 1) {
            if ($alt) {
                $type .= "_$alt";
                $types_seen{$type}++;
            }
            else {
                if ($types_alt{$type}) {
                    # rename previous hash key
                    my $newtype = $type . '_' . $types_alt{$type};
                    $tailoring->{$newtype} = $tailoring->{$type};
                    $types_seen{$newtype}++;
                    delete $tailoring->{$type};
                } else {
                    carp "Collation of type $type encountered again for locale $locale_id. Ignoring";
                    next
                }
            }
        }

       ## check if alias then register it // THIS IS NOT USED IN CLDR as of version 1.8
       if ( $c->exists('alias') ) {
           croak "Handling of /ldml/collations/collation/alias not yet supported";
       #    my $alias = $c->findvalue('alias');
       #    etc
       }

        # then get the collation settings
        my %settings;
        if ( $c->exists('settings') ) {
            my $settings_node = $c->findnodes('settings')->get_node(1);
            if ($settings_node->hasAttributes) {
                my @attrlist = $settings_node->attributes();
                foreach my $attr ( @attrlist ) {
                    #print "attribute: " . $attr->nodeName . " = " . $attr->to_literal . "\n";
                    $settings{$attr->nodeName} = $attr->to_literal;
                }
            }
        }

        if ( $c->exists('suppress_contractions') ) {
            my $suppr_contr = $c->findvalue('suppress_contractions');
            $settings{suppress_contractions} = $suppr_contr
        }

        #OMITTED
        if ( $c->exists('optimize') ) {
            say "NB: 'optimize' data omitted for locale '$locale_id' and collation type '$type'";
        #    my $optimize = $c->findvalue('optimize');
        #    $settings{optimize} = $optimize
        }

        $tailoring->{$type}->{settings} = { %settings } if %settings;

        #TODO get elements "suppress_contractions", "optimize", and "special"
        #   but ignore them for now!

        #TODO Check if "base" ref then register it
        #   (NB: as of CLDR 1.8 this is not used)
        croak "Handling of '/ldml/collations/collation/base' not yet supported"
            if $c->exists('base');

        #parse rules:
        my $rules_node = $c->findnodes('rules')->get_node(1);

        if ($rules_node) {
            croak "Handling of '/ldml/collations/collation/rules/alias' not yet supported"
                if $rules_node->exists('alias');
            #TODO catch 'rules/alias' if any, else process_rules()
            $tailoring->{$type}->{rules} = process_rules($rules_node) ;
        }
    }

    $tailoring->{types} = [ keys %types_seen ];

    return $tailoring
}

sub process_rules {
    my $collnode = shift;
    my $str = '';
    foreach my $child ($collnode->childNodes) {
        next unless $child->nodeType == 1; # XML_ELEMENT_NODE = 1
        my $name = $child->nodeName;
        if ( $name eq 'reset' ) {
            $str .= "\n" unless $str eq '';
            $str .= "& " ;
            if ( $child->exists('@before') ) {
                my $before_value = $child->find('@before')->string_value;
                $str .= '[before ' . $levelNames{$before_value} . '] ';
            }
            if ( $child->childNodes->[0]->nodeType == 1 ) {
                my $name = $child->childNodes->[0]->nodeName;
                if (first { $name eq $_ } @logicalResets) {
                    $str .= "[$name] "
                }
                else {
                    croak "Unknown logical reset $name"
                }
            }
            else {
                $str .= $child->string_value . ' ';
            }
        }
        elsif ($name eq 'x') {
            my $xstr = '';
            foreach my $grandchild ($child->childNodes) {
                $xstr .= process_rule($grandchild);
            }
            # put context after the rule operator
            if ($child->exists('context')) {
                $xstr =~ s/^\| (\S+) (<+|=)/$2 $1 |/;
            }
            $str .= $xstr
        }
        else {
            $str .= process_rule($child) ;
        }
    }
    return $str
}

sub process_rule {
    my $node = shift;
    my $type = $node->nodeName;
    #TODO if $node has childNode of nodeType == 1
    #  then use "[$child->nodeName]" if it is in @logicalReset
    #  else use string_value:
    my $value = $node->string_value;
    my @chars = ($value);
    my $optype = '???'; # to indicate unimplemented elements
    my $basetype = $type;
    if ( $type =~ /^[psti]c$/ ) {
        $basetype =~ s/c$//;
        @chars = split //, $value;
    }
    if ( exists $operators{$basetype} ) {
        $optype = $operators{$basetype} ;
    } else {
        carp "Unable to handle unknown element $basetype";
    }

    my $str = '';
    foreach my $char (@chars) {
        if ($char eq ' ') { # this occurs in the tailoring for Thai
            $char = '[space]'
        };
        $str .= $optype . ' ' . $char . ' ';
    }

    return $str;
}

# Dump a hashref as a hash
# (has the advantage over dumping a hash that it keeps the => operators intact)
sub dump_hash {
    my $hashref = shift;
    my $dump = Data::Dump::pp($hashref);
    $dump =~ s/^(\s*){/$1(/m;
    $dump =~ s/}(\s*)$/)$1/m;
    return $dump
}

#############################################################

foreach my $infile (@ldml_files) {
    my (undef,undef,$file) = File::Spec->splitpath($infile);
    my ($locale_id) = $file =~ /^(.+)\.xml$/;
    #say "Processing LDML for locale $locale_id";
    my $ldml = $parser->parse_file($infile);
    my $xpc = XML::LibXML::XPathContext->new($ldml);

    #get locales which use the generic UCA
    if ($locale_id eq 'root') {
        my @uca_locales = split(/\s+/, $xpc->findvalue('/ldml/collations/@validSubLocales'));
        foreach my $l (@uca_locales) {
            $aliases{$l} = 'default'
        }
        next
    }
    if ($xpc->exists('/ldml/collations/@validSubLocales')) {
        my @sublocales = split(/\s+/, $xpc->findvalue('/ldml/collations/@validSubLocales'));
        foreach my $l (@sublocales) {
            #TODO warn if exists $aliases{$l}
            $aliases{$l} = $locale_id
        }
    }
    #check for '/ldml/collations/alias'
    if ( $xpc->exists('/ldml/collations/alias') ) {
        my $alias = $xpc->findvalue('/ldml/collations/alias/@source');
        #...
        #TODO warn if exists $aliases{$locale_id}
        $aliases{$locale_id} = $alias;
        next
    }
    $tailorings{$locale_id} = parse_ldml($xpc, $locale_id);

    next if $aliases_with_type{$locale_id};

    my $outfile = File::Spec->catfile($Locale_Dir, "$locale_id.pm");
    my $fh   = new IO::File ("> $outfile");
    my $out  = $COMMENT_HEADER;
    my $dump = dump_hash($tailorings{$locale_id});
    $dump =~ s/^/    /gm;
    $dump =~ s/rules => "(.+)",\s*$/rules => <<END,\n$1\nEND/gm;
    $dump =~ s/\\n/\n/g;
    $out .= "package Unicode::Collate::Locale::$locale_id;\n\n";
    $out .= "our %tailoring = \n" . $dump . ";\n\n";
    $out .= "1;\n";
    #$dump =~ s/^(&.+)$/wrap('', '', $1)/gme;
#    $tt->process(
#        \$Locale_ID_tt,
#        {
#            cldr_version   => $CLDR_Version,
#            locale_id      => $locale_id,
#            tailoring_dump => $dump
#        },
#        \$out);
    print $fh $out;
    undef $fh;
    push @available_locales, $locale_id;
}

#TODO check aliases for consistency, non-circularity, availability, etc.

###################################################
## WRITE U::C::Locale::Data
###################################################
my $output  = $COMMENT_HEADER;
my $Locale_Data = File::Spec->catfile($Locale_Dir, "Data.pm");

$output .= "package Unicode::Collate::Locale::Data;\n\n";

$output .= "our %aliases = " . dump_hash(\%aliases) . ";\n\n";

$output .= "our %aliases_with_type = " . dump_hash(\%aliases_with_type) . ";\n\n";

$output .= "our \@available_locales = " . Data::Dump::pp(@available_locales) . ";\n\n";

$output .= "1;\n";

#$tt->process( \$Locale_Data_tt,
#    { cldr_version => $stash{cldr_version},
#      aliases => dump_hash(\%aliases),
#      aliases_with_type => dump_hash(\%aliases_with_type),
#      available_locales => Data::Dump::pp(@available_locales),
#    },
#    \$output );

my $output_tidy = '';
Perl::Tidy::perltidy(source=>\$output, destination=>\$output_tidy);

my $fh = new IO::File ("> $Locale_Data");
print $fh $output_tidy;
undef $output_tidy;
